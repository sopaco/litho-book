# **Litho-Book ç³»ç»Ÿæ”¯æ’‘åŸŸæŠ€æœ¯å®ç°æ–‡æ¡£**

---

## **1. æ¨¡å—æ¦‚è¿°**

**ç³»ç»Ÿæ”¯æ’‘åŸŸï¼ˆSystem Infrastructure Domainï¼‰** æ˜¯ Litho-Book é¡¹ç›®ä¸­è´Ÿè´£æä¾›é€šç”¨åŸºç¡€è®¾æ–½èƒ½åŠ›çš„æ ¸å¿ƒæ¨¡å—ï¼Œä¸ç›´æ¥å‚ä¸ä¸šåŠ¡é€»è¾‘å¤„ç†ï¼Œè€Œæ˜¯ä¸ºæ•´ä¸ªç³»ç»Ÿçš„ç¨³å®šè¿è¡Œã€é”™è¯¯ä¸€è‡´æ€§ä¸ç”Ÿå‘½å‘¨æœŸç®¡ç†æä¾›åº•å±‚ä¿éšœã€‚è¯¥æ¨¡å—éµå¾ªâ€œé«˜å†…èšã€ä½è€¦åˆâ€çš„è®¾è®¡åŸåˆ™ï¼Œç¡®ä¿æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼ˆå¦‚æ–‡æ¡£æµè§ˆã€AI èŠå¤©ï¼‰èƒ½å¤Ÿä¸“æ³¨äºåŠŸèƒ½å®ç°ï¼Œè€Œä¸å¿…å…³å¿ƒæ—¥å¿—ã€é”™è¯¯æ˜ å°„æˆ–æœåŠ¡å¯åŠ¨ç­‰æ¨ªåˆ‡å…³æ³¨ç‚¹ã€‚

æ ¹æ®è°ƒç ”ææ–™ï¼Œç³»ç»Ÿæ”¯æ’‘åŸŸåŒ…å«ä¸¤ä¸ªå…³é”®å­æ¨¡å—ï¼š
- **é”™è¯¯å¤„ç†ä¸­æ¢ï¼ˆError Handling Hubï¼‰**
- **ç¨‹åºå¯åŠ¨åè°ƒå™¨ï¼ˆApplication Startup Coordinatorï¼‰**

è¿™ä¸¤ä¸ªç»„ä»¶å…±åŒæ„æˆäº†åº”ç”¨çš„â€œéª¨æ¶â€ï¼Œæ˜¯è¿æ¥ç”¨æˆ·äº¤äº’åŸŸä¸æ–‡æ¡£æ•°æ®åŸŸçš„æ¡¥æ¢ï¼Œä¹Ÿæ˜¯ç³»ç»Ÿå¥å£®æ€§çš„é‡è¦åŸºçŸ³ã€‚

---

## **2. å­æ¨¡å—æŠ€æœ¯å®ç°è¯¦è§£**

### **2.1 é”™è¯¯å¤„ç†ä¸­æ¢ï¼ˆ`error.rs`ï¼‰**

#### **2.1.1 è®¾è®¡ç›®æ ‡**
- ç»Ÿä¸€ç®¡ç†æ‰€æœ‰è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- å®ç°ä»å†…éƒ¨é”™è¯¯åˆ° HTTP çŠ¶æ€ç çš„è‡ªåŠ¨è½¬æ¢
- æä¾›æ¸…æ™°çš„é”™è¯¯è¯­ä¹‰å’Œä¸Šä¸‹æ–‡ä¿¡æ¯
- æ”¯æŒè·¨æ¨¡å—é”™è¯¯ä¼ æ’­ä¸é›†ä¸­å¤„ç†

#### **2.1.2 æ ¸å¿ƒå®ç°æœºåˆ¶**

ä½¿ç”¨ `thiserror` åº“å®šä¹‰æšä¸¾å‹é”™è¯¯ç±»å‹ `LithoBookError`ï¼Œå¹¶é€šè¿‡ `From` trait è‡ªåŠ¨æ˜ å°„ä¸º `axum::http::StatusCode`ï¼Œä»è€Œåœ¨ Web å±‚å®ç°ç»Ÿä¸€å“åº”ã€‚

```rust
// src/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum LithoBookError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("JSON serialization error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("File not found: {path}")]
    FileNotFound { path: String },

    #[error("Invalid file path: {path}")]
    InvalidPath { path: String },

    #[error("Directory scan error: {0}")]
    DirectoryScan(String),

    #[error("Server error: {0}")]
    Server(String),

    #[error("Configuration error: {0}")]
    Config(String),
}
```

> âœ… **ä¼˜åŠ¿è¯´æ˜**ï¼š  
> - `#[from]` å±æ€§å…è®¸è‡ªåŠ¨è½¬æ¢ `std::io::Error` å’Œ `serde_json::Error`ï¼Œå‡å°‘æ ·æ¿ä»£ç ã€‚
> - æ¯ä¸ªå˜ä½“éƒ½å®ç°äº† `Display` traitï¼Œä¾¿äºæ—¥å¿—è¾“å‡ºå’Œè°ƒè¯•ã€‚

#### **2.1.3 HTTP çŠ¶æ€ç æ˜ å°„æœºåˆ¶**

é€šè¿‡å®ç° `From<LithoBookError> for axum::http::StatusCode`ï¼Œå°†åº”ç”¨çº§é”™è¯¯è‡ªåŠ¨è½¬æ¢ä¸ºæ ‡å‡† HTTP å“åº”ç ï¼š

```rust
impl From<LithoBookError> for axum::http::StatusCode {
    fn from(err: LithoBookError) -> Self {
        match err {
            LithoBookError::FileNotFound { .. } => StatusCode::NOT_FOUND,
            LithoBookError::InvalidPath { .. } => StatusCode::BAD_REQUEST,
            LithoBookError::Json(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LithoBookError::Io(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LithoBookError::DirectoryScan(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LithoBookError::Server(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LithoBookError::Config(_) => StatusCode::BAD_REQUEST,
        }
    }
}
```

> ğŸ”„ **è°ƒç”¨é“¾ç¤ºä¾‹**ï¼š
> ```text
> filesystem::get_file_content() â†’ Err(FileNotFound) 
> â†’ Axum è‡ªåŠ¨è°ƒç”¨ .into() â†’ StatusCode::NOT_FOUND 
> â†’ è¿”å› 404 å“åº”ç»™å‰ç«¯
> ```

#### **2.1.4 ä½¿ç”¨æ–¹å¼ï¼ˆåœ¨è·¯ç”±å¤„ç†å™¨ä¸­ï¼‰**

Axum æ”¯æŒå°†ä»»æ„ç±»å‹ `T: Into<axum::response::Response>` ä½œä¸ºè¿”å›å€¼ã€‚ç»“åˆ `anyhow::Result<T, E>` ä¸ `.map_err(Into::into)` å¯æ— ç¼é›†æˆï¼š

```rust
async fn get_file_handler(
    Query(params): Query<FileQuery>,
    State(state): State<AppState>,
) -> Result<Json<FileResponse>, StatusCode> {
    let content = state.doc_tree.get_file_content(&file_path)
        .map_err(|e| {
            error!("Failed to read file {}: {}", file_path, e);
            StatusCode::NOT_FOUND
        })?;
    // ...
}
```

æˆ–è€…æ›´ä¼˜é›…åœ°ä½¿ç”¨ `?` æ“ä½œç¬¦é…åˆå…¨å±€é”™è¯¯ç±»å‹ï¼š

```rust
type ApiResult<T> = Result<T, LithoBookError>;

async fn search_handler(...) -> ApiResult<Json<SearchResponse>> {
    let results = doc_tree.search_content(query)?;
    Ok(Json(SearchResponse { ... }))
}
```

æ­¤æ—¶ Axum ä¼šè‡ªåŠ¨è°ƒç”¨ `From<LithoBookError>` å®ŒæˆçŠ¶æ€ç è½¬æ¢ã€‚

---

### **2.2 ç¨‹åºå¯åŠ¨åè°ƒå™¨ï¼ˆ`main.rs`ï¼‰**

#### **2.2.1 æ¨¡å—èŒè´£**
ä½œä¸ºåº”ç”¨ç¨‹åºçš„ä¸»å…¥å£å‡½æ•°ï¼Œ`main()` å‡½æ•°æ‰¿æ‹…äº†ä»¥ä¸‹å…³é”®èŒè´£ï¼š
1. è§£æå‘½ä»¤è¡Œå‚æ•°
2. åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
3. æ‰“å°å¯åŠ¨æ¨ªå¹…
4. éªŒè¯é…ç½®åˆæ³•æ€§
5. æ„å»ºæ–‡æ¡£æ ‘ç»“æ„
6. åˆ›å»ºå¹¶ç»‘å®š Web æœåŠ¡
7. è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ï¼ˆå¯é€‰ï¼‰

å…¶æœ¬è´¨æ˜¯ä¸€ä¸ª**æµç¨‹è°ƒåº¦ä¸­å¿ƒ**ï¼Œåè°ƒå„æ¨¡å—å®Œæˆç³»ç»Ÿåˆå§‹åŒ–ã€‚

#### **2.2.2 å¯åŠ¨æµç¨‹å›¾è§£**

```mermaid
flowchart TD
    A[ç”¨æˆ·æ‰§è¡Œå‘½ä»¤] --> B[è§£æ CLI å‚æ•°]
    B --> C[åˆå§‹åŒ– Tracing æ—¥å¿—]
    C --> D[æ‰“å°å¯åŠ¨ Banner]
    D --> E[éªŒè¯è·¯å¾„/ç«¯å£æƒé™]
    E --> F[æ‰«æ docs ç›®å½•æ„å»º DocumentTree]
    F --> G[åˆ›å»º Axum Router å¹¶æ³¨å…¥ AppState]
    G --> H[ç»‘å®š TCP Listener]
    H --> I[å¯åŠ¨å¼‚æ­¥æœåŠ¡å™¨]
    I --> J{æ˜¯å¦å¯ç”¨ --open?}
    J -->|æ˜¯| K[è·¨å¹³å°è°ƒç”¨æµè§ˆå™¨]
    J -->|å¦| L[ç­‰å¾… Ctrl+C åœæ­¢]
```

#### **2.2.3 å…³é”®æŠ€æœ¯ç»†èŠ‚**

##### ï¼ˆ1ï¼‰å¼‚æ­¥ä¸»å‡½æ•°å£°æ˜
```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> { ... }
```
- ä½¿ç”¨ `tokio::main` å®å¯åŠ¨å¼‚æ­¥è¿è¡Œæ—¶
- è¿”å› `anyhow::Result` ç±»å‹ä»¥æ”¯æŒä»»æ„é”™è¯¯ç±»å‹çš„ä¼ æ’­

##### ï¼ˆ2ï¼‰æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–ï¼ˆ`init_logging`ï¼‰
åŸºäº `tracing` + `tracing-subscriber` å®ç°ç»“æ„åŒ–æ—¥å¿—ï¼š

```rust
fn init_logging(verbose: bool) {
    let filter = if verbose {
        tracing_subscriber::filter::LevelFilter::DEBUG
    } else {
        tracing_subscriber::filter::LevelFilter::INFO
    };

    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer().without_time().with_target(false))
        .with(filter)
        .init();
}
```

> âš ï¸ å½“å‰æœªè®°å½•æ–‡ä»¶å/è¡Œå·ï¼Œé€‚åˆç”Ÿäº§ç¯å¢ƒï¼›è‹¥éœ€è°ƒè¯•å¯å¼€å¯ `.with_file(true).with_line_number(true)`ã€‚

##### ï¼ˆ3ï¼‰è·¨å¹³å°æµè§ˆå™¨è‡ªåŠ¨æ‰“å¼€ï¼ˆ`open_browser`ï¼‰

åˆ©ç”¨æ¡ä»¶ç¼–è¯‘å®ç°å¤šå¹³å°å…¼å®¹ï¼š

```rust
#[cfg(target_os = "windows")]
fn open_browser(url: &str) -> anyhow::Result<()> {
    std::process::Command::new("cmd").args(["/c", "start", "", url]).spawn()?;
}

#[cfg(target_os = "macos")]
fn open_browser(url: &str) -> anyhow::Result<()> {
    std::process::Command::new("open").arg(url).spawn()?;
}

#[cfg(target_os = "linux")]
fn open_browser(url: &str) -> anyhow::Result<()> {
    let browsers = ["xdg-open", "firefox", "chromium", "google-chrome"];
    for browser in &browsers {
        if std::process::Command::new(browser).arg(url).spawn().is_ok() {
            return Ok(());
        }
    }
    anyhow::bail!("No suitable browser found");
}
```

> âœ… **å¥å£®æ€§è®¾è®¡**ï¼šå¤±è´¥æ—¶ä¸ä¸­æ–­æœåŠ¡ï¼Œä»…è®°å½•è­¦å‘Šæ—¥å¿—ã€‚

##### ï¼ˆ4ï¼‰TCP æœåŠ¡ç»‘å®šä¸ç›‘å¬**

ä½¿ç”¨ `tokio::net::TcpListener` å¼‚æ­¥ç»‘å®šåœ°å€ï¼š

```rust
let listener = TcpListener::bind(&bind_address).await?;
info!("æœåŠ¡å™¨ç»‘å®šæˆåŠŸ: {}", bind_address);

axum::serve(listener, app).await?;
```

- è‹¥ç«¯å£è¢«å ç”¨æˆ–æ— æƒé™ï¼Œæå‰é€€å‡ºå¹¶æç¤ºç”¨æˆ·
- ä½¿ç”¨ `axum::serve()` å¯åŠ¨éé˜»å¡æœåŠ¡

##### ï¼ˆ5ï¼‰AppState æ³¨å…¥æœºåˆ¶**

å°† `DocumentTree` å’Œ `docs_path` å°è£…è¿›å…±äº«çŠ¶æ€ï¼Œä¾›æ‰€æœ‰è·¯ç”±è®¿é—®ï¼š

```rust
let state = AppState {
    doc_tree,
    docs_path,
};

let app = Router::new()
    .route("/", get(index_handler))
    .with_state(state); // â† å…¨å±€çŠ¶æ€æ³¨å…¥
```

> ğŸ” **å®‰å…¨æ€§æ³¨æ„**ï¼š`AppState` å¿…é¡»å®ç° `Clone` æˆ– `Sync + Send`ï¼Œæ­¤å¤„é‡‡ç”¨ `#[derive(Clone)]`ã€‚

---

## **3. æ¨¡å—é—´åä½œå…³ç³»åˆ†æ**

| è°ƒç”¨æ–¹ | è¢«è°ƒç”¨æ–¹ | åä½œæ–¹å¼ | è¯´æ˜ |
|--------|----------|---------|------|
| `main.rs` | `cli.rs` | æœåŠ¡è°ƒç”¨ | ä¸»ç¨‹åºè°ƒç”¨ `Args::parse()` è·å–é…ç½® |
| `main.rs` | `filesystem.rs` | æ•°æ®ä¾èµ– | æ„å»º `DocumentTree` å¹¶æ³¨å…¥çŠ¶æ€ |
| `main.rs` | `server.rs` | æœåŠ¡è°ƒç”¨ | åˆ›å»ºè·¯ç”±å™¨å¹¶ä¼ å…¥çŠ¶æ€ |
| `server.rs` | `error.rs` | é”™è¯¯æ˜ å°„ | æ‰€æœ‰é”™è¯¯æœ€ç»ˆè½¬ä¸º HTTP çŠ¶æ€ç  |
| `filesystem.rs` | `error.rs` | é”™è¯¯åŒ…è£… | IO/JSON é”™è¯¯å°è£…ä¸º `LithoBookError` |

> ğŸ§© **æ¶æ„ä»·å€¼**ï¼šç³»ç»Ÿæ”¯æ’‘åŸŸå¤„äºè°ƒç”¨é“¾ä¸Šæ¸¸ï¼Œæ—¢å‘èµ·æµç¨‹åˆæ¥æ”¶å¼‚å¸¸ï¼Œèµ·åˆ°äº†â€œç²˜åˆå‰‚â€ä½œç”¨ã€‚

---

## **4. å¯é æ€§ä¸æ‰©å±•æ€§è¯„ä¼°**

### **4.1 å·²å…·å¤‡çš„ä¼˜åŠ¿**
- âœ… **ç»Ÿä¸€é”™è¯¯å¤„ç†**ï¼šå‰åç«¯ä¸€è‡´çš„é”™è¯¯åé¦ˆæœºåˆ¶
- âœ… **æ¸…æ™°çš„å¯åŠ¨æµç¨‹**ï¼šçº¿æ€§åŒ–æ§åˆ¶æµæ˜“äºç†è§£å’Œç»´æŠ¤
- âœ… **è·¨å¹³å°å…¼å®¹æ€§**ï¼šWindows/macOS/Linux æµè§ˆå™¨è‡ªåŠ¨æ‰“å¼€
- âœ… **å¼‚æ­¥é«˜æ€§èƒ½**ï¼šåŸºäº Tokio çš„éé˜»å¡ I/O æ¨¡å‹
- âœ… **æ—¥å¿—åˆ†çº§æ§åˆ¶**ï¼šæ”¯æŒ `--verbose` è¾“å‡ºè¯¦ç»†æ—¥å¿—

### **4.2 æ½œåœ¨æ”¹è¿›æ–¹å‘**

| é—®é¢˜ | å»ºè®®æ–¹æ¡ˆ |
|------|---------|
| API å¯†é’¥ç¡¬ç¼–ç  | æ”¹ä¸ºç¯å¢ƒå˜é‡ `ZHIPUAI_API_KEY` åŠ è½½ |
| HTML æ¨¡æ¿å†…è” | å¤–ç½® `templates/index.html.tpl` æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘ |
| ç¼ºå°‘é…ç½®æ–‡ä»¶ | å¢åŠ  `litho-book.toml` æ”¯æŒæŒä¹…åŒ–é…ç½® |
| æ— çƒ­é‡è½½æœºåˆ¶ | ç›‘å¬æ–‡ä»¶å˜åŒ–ï¼ŒåŠ¨æ€é‡å»º `DocumentTree` |
| å†…å­˜å ç”¨è¾ƒé«˜ | å¯¹æ¸²æŸ“ç»“æœæ·»åŠ  LRU ç¼“å­˜ï¼ˆå¦‚ `lru` crateï¼‰ |

---

## **5. æ€»ç»“**

**ç³»ç»Ÿæ”¯æ’‘åŸŸ**è™½ä¸ç›´æ¥é¢å‘ç”¨æˆ·éœ€æ±‚ï¼Œå´æ˜¯ Litho-Book é«˜å¯ç”¨æ€§çš„æ ¸å¿ƒä¿éšœã€‚å®ƒé€šè¿‡ä¸¤å¤§æ”¯æŸ±â€”â€”**ç»Ÿä¸€é”™è¯¯å¤„ç†æœºåˆ¶**ä¸**ç¨‹åºå¯åŠ¨åè°ƒé€»è¾‘**â€”â€”å®ç°äº†ä»¥ä¸‹ä»·å€¼ï¼š

- **ç¨³å®šæ€§å¢å¼º**ï¼šé€šè¿‡æ ‡å‡†åŒ–é”™è¯¯æ˜ å°„é¿å…æœªæ•è·å¼‚å¸¸å¯¼è‡´çš„æœåŠ¡å´©æºƒ
- **å¼€å‘æ•ˆç‡æå‡**ï¼šå¼€å‘è€…æ— éœ€æ‰‹åŠ¨å¤„ç†æ¯ç§é”™è¯¯å¯¹åº”çš„ HTTP çŠ¶æ€ç 
- **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**ï¼šè‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ã€å½©è‰²æ—¥å¿—æç¤ºã€å¯åŠ¨ç»Ÿè®¡ä¿¡æ¯å±•ç¤º
- **æ¶æ„æ¸…æ™°åŒ–**ï¼šæ˜ç¡®åˆ’åˆ†å…³æ³¨ç‚¹ï¼Œä½¿ä¸»æµç¨‹é«˜åº¦å¯è¯»ä¸”æ˜“äºæµ‹è¯•

è¯¥æ¨¡å—çš„è®¾è®¡å……åˆ†ä½“ç°äº† Rust ç”Ÿæ€åœ¨ç±»å‹å®‰å…¨ã€é›¶æˆæœ¬æŠ½è±¡å’Œå·¥ç¨‹å®è·µä¸Šçš„ä¼˜åŠ¿ï¼Œæ˜¯ç°ä»£å…¨æ ˆåº”ç”¨ä¸­ä¸å¯æˆ–ç¼ºçš„åŸºç¡€ç»„ä»¶ã€‚

--- 

> ğŸ“Œ **é™„å½•ï¼šæ ¸å¿ƒä¾èµ–æ¸…å•ï¼ˆCargo.toml ç‰‡æ®µï¼‰**
> ```toml
> [dependencies]
> thiserror = "1.0"
> anyhow = "1.0"
> tracing = "0.1"
> tracing-subscriber = "0.3"
> tokio = { version = "1.47", features = ["full"] }
> ```