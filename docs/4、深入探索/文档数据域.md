# 文档数据域技术实现文档

## 1. 模块概述

**文档数据域**是 Litho Book 系统的核心业务模块，负责将本地文件系统中的 Markdown 文档转换为结构化、可搜索、可导航的内存数据模型。该模块作为系统的知识内容核心载体与处理引擎，实现了从原始文件到结构化知识库的转化过程。

### 核心职责
- **文档树构建**：递归扫描指定目录，构建包含元数据的树形结构
- **全文检索**：提供基于关键词的智能搜索能力，支持相关性排序与高亮显示
- **内容渲染**：将 Markdown 源码转换为前端可用的 HTML 格式
- **状态管理**：维护文档统计信息与搜索索引，支持高效查询

### 技术定位
作为系统的核心业务域，文档数据域位于架构的中心位置，向上为用户交互域提供数据服务，向下依赖系统支撑域进行错误处理。其设计体现了高内聚、低耦合的原则，通过清晰的接口与其他模块通信。

---

## 2. 核心数据结构

### 2.1 `DocumentTree` 结构体

`DocumentTree` 是整个模块的核心数据容器，封装了文档目录的完整内存表示：

```rust
pub struct DocumentTree {
    pub root: FileNode,
    pub file_map: HashMap<String, PathBuf>,
    pub stats: TreeStats,
    pub search_index: HashMap<String, Vec<String>>,
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| `root` | `FileNode` | 文档树的根节点，包含所有子节点 |
| `file_map` | `HashMap<String, PathBuf>` | 文件路径映射表，用于快速查找物理路径 |
| `stats` | `TreeStats` | 文档库的统计信息（文件数、大小等） |
| `search_index` | `HashMap<String, Vec<String>>` | 全文搜索索引，存储每个文件的行文本 |

### 2.2 `FileNode` 节点结构

`FileNode` 表示树中的单个节点，既可以是目录也可以是文件：

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileNode {
    pub name: String,
    pub path: String,
    pub is_file: bool,
    pub children: Vec<FileNode>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modified: Option<String>,
}
```

关键特性：
- **序列化支持**：通过 `serde` 实现 JSON 序列化，便于传输给前端
- **条件序列化**：`size` 和 `modified` 字段在为空时不输出，减少网络传输量
- **树形结构**：通过 `children` 向量实现递归嵌套，天然支持目录层级

### 2.3 搜索结果结构

#### `SearchResult`
表示单个文件的搜索匹配结果：

```rust
pub struct SearchResult {
    pub file_path: String,
    pub file_name: String,
    pub title: Option<String>,
    pub matches: Vec<SearchMatch>,
    pub relevance_score: f32,
}
```

#### `SearchMatch`
表示文件中具体的匹配项：

```rust
pub struct SearchMatch {
    pub line_number: usize,
    pub content: String,
    pub highlighted_content: String,
    pub context_before: Option<String>,
    pub context_after: Option<String>,
}
```

搜索结果设计特点：
- **上下文感知**：包含前后文片段，帮助用户理解匹配内容的语境
- **高亮标记**：预生成带 `<mark>` 标签的内容，减轻前端负担
- **相关性评分**：量化匹配质量，支持结果排序

---

## 3. 核心功能实现

### 3.1 文档树构建流程

文档树的构建是一个递归过程，始于 `DocumentTree::new()` 方法：

```rust
pub fn new(docs_dir: &Path) -> anyhow::Result<Self>
```

#### 构建步骤
1. **初始化组件**：创建 `file_map`、`search_index` 和 `stats` 统计器
2. **读取目录内容**：使用 `std::fs::read_dir()` 获取目录条目
3. **排序处理**：按类型（目录优先）和名称排序，确保一致的展示顺序
4. **过滤文件**：
   - 跳过隐藏文件（以 `.` 开头）
   - 仅保留 `.md` 扩展名的文件
5. **递归构建**：对每个有效条目调用 `build_tree()` 进行深度遍历
6. **创建虚拟根**：包装实际目录内容，形成统一的树结构

#### 关键算法：`build_tree()`

```rust
fn build_tree(
    current_path: &Path,
    base_path: &Path,
    file_map: &mut HashMap<String, PathBuf>,
    search_index: &mut HashMap<String, Vec<String>>,
    stats: &mut TreeStats,
) -> anyhow::Result<FileNode>
```

该方法根据路径类型执行不同逻辑：
- **文件处理**：
  - 计算相对路径并存入 `file_map`
  - 读取文件内容构建 `search_index`
  - 更新统计信息
- **目录处理**：
  - 递归处理子条目
  - 收集子节点构建 `children` 向量

#### 路径处理策略
- **相对路径标准化**：使用 `/` 作为分隔符，兼容跨平台
- **基础路径剥离**：移除文档根目录前缀，避免暴露绝对路径
- **URL友好格式**：替换反斜杠，便于在 Web 路由中使用

### 3.2 全文搜索引擎

#### 搜索流程 (`search_content`)
```rust
pub fn search_content(&self, query: &str) -> Vec<SearchResult>
```

1. **输入验证**：空查询直接返回空结果
2. **预处理**：将查询词转为小写，实现不区分大小写的搜索
3. **遍历索引**：对 `search_index` 中的每个文件执行匹配
4. **行级匹配**：逐行检查是否包含查询词
5. **评分计算**：综合多种因素确定相关性
6. **结果排序**：按评分降序排列，截取前50条

#### 相关性评分算法

系统采用多维度加权评分机制，总分为各因素得分之和：

| 因素 | 权重 | 说明 |
|------|------|------|
| 标题匹配 | ×3 | 匹配到以 `#` 开头的标题行 |
| 精确词匹配 | ×2 | 查询词作为独立单词出现 |
| 行首匹配 | ×1.5 | 匹配出现在行首位置 |
| 文件名匹配 | +2 | 文件名中包含查询词 |

**评分示例**：
```text
查询："性能优化"
文件：performance.md
内容：# 性能优化指南
      本文介绍如何进行性能优化...

计算：
- 标题匹配：1.0 × 3 = 3.0
- 精确匹配：1.0 × 2 = 2.0  
- 行首匹配：无
- 文件名匹配：+2.0
总分：7.0
```

#### 高亮实现 (`highlight_matches`)

```rust
fn highlight_matches(&self, content: &str, query: &str) -> String
```

采用简单的字符串查找与替换策略：
1. 在内容中查找查询词的位置
2. 将匹配部分包裹在 `<mark>` HTML 标签中
3. 保持原文本的其他部分不变

此实现保证了高亮的准确性，同时避免了复杂的正则表达式解析开销。

### 3.3 Markdown 渲染器

#### 渲染实现 (`render_markdown`)

```rust
pub fn render_markdown(&self, content: &str) -> String
```

基于 `pulldown-cmark` 库实现，配置了丰富的扩展语法支持：

```rust
let mut options = Options::empty();
options.insert(Options::ENABLE_TABLES);
options.insert(Options::ENABLE_FOOTNOTES);
options.insert(Options::ENABLE_STRIKETHROUGH);
options.insert(Options::ENABLE_TASKLISTS);
options.insert(Options::ENABLE_SMART_PUNCTUATION);
options.insert(Options::ENABLE_HEADING_ATTRIBUTES);
```

支持的 Markdown 特性：
- 表格
- 脚注
- 删除线
- 任务列表
- 智能标点
- 标题属性

渲染过程完全在服务端完成，确保前端接收到的是标准 HTML，降低了客户端的处理复杂度。

---

## 4. 模块交互与集成

### 4.1 与用户交互域的集成

文档数据域通过 `AppState` 注入到 Axum Web 服务中，供各个路由处理器使用：

```rust
// src/server.rs
#[derive(Clone)]
pub struct AppState {
    pub doc_tree: DocumentTree,
    pub docs_path: String,
}

// 创建路由器时注入状态
let app = server::create_router(doc_tree, docs_path);
```

主要交互场景：

#### 文档浏览
```rust
async fn file_handler(
    State(state): State<AppState>, 
    Query(query): Query<FileQuery>
) -> Result<Json<FileResponse>, StatusCode> {
    let content = state.doc_tree.get_file_content(&query.file.unwrap())?;
    let html = state.doc_tree.render_markdown(&content);
    // ...
}
```

#### 全文搜索
```rust
async fn search_handler(
    State(state): State<AppState>, 
    Query(query): Query<SearchQuery>
) -> Result<Json<SearchResponse>, StatusCode> {
    let results = state.doc_tree.search_content(&query.q.unwrap());
    // ...
}
```

### 4.2 与 AI 助手的协同

在 AI 对话流程中，文档数据域提供上下文支持：

```rust
async fn chat_stream_handler(
    State(state): State<AppState>,
    Json(request): Json<ChatRequest>,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    // 获取当前文档内容作为上下文
    let context = request.context;
    
    // 构建AI请求时包含文档上下文
    call_openai_stream_api(&request.message, context, ...).await
}
```

此外，系统还会自动加载特定文档（如"架构概览.md"）作为背景知识，增强 AI 的回答质量。

### 4.3 错误处理集成

文档数据域遵循统一的错误处理规范，通过 `anyhow` 和 `thiserror` 库进行错误传播：

```rust
use anyhow::Result;

pub fn get_file_content(&self, file_path: &str) -> anyhow::Result<String> {
    let path = self.file_map.get(file_path)
        .ok_or_else(|| anyhow::anyhow!("File not found: {}", file_path))?;
    
    std::fs::read_to_string(path)
        .map_err(|e| anyhow::anyhow!("Failed to read file {}: {}", path.display(), e))
}
```

这些错误最终会被系统支撑域的 `LithoBookError` 映射为适当的 HTTP 状态码，确保前后端一致的错误反馈。

---

## 5. 性能与优化考量

### 5.1 内存使用分析

文档数据域在内存中维护多个数据结构：
- **文档树**：O(n) 空间复杂度，n 为文件和目录总数
- **文件映射**：O(m) 空间复杂度，m 为 Markdown 文件数量
- **搜索索引**：O(k) 空间复杂度，k 为所有文件的总行数

对于典型的文档库（数百个文件），内存占用通常在几十到几百 MB 量级。

### 5.2 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 文档树构建 | O(n) | n 为文件系统节点总数 |
| 文件查找 | O(1) | 哈希表查找 |
| 单文件读取 | O(1) | 通过 `file_map` 定位后读取 |
| 全文搜索 | O(k) | k 为索引中的总行数 |

### 5.3 潜在优化方向

尽管当前实现已具备良好性能，但仍存在以下优化空间：

#### 缓存机制
- **渲染结果缓存**：对频繁访问的文件添加 LRU 缓存，避免重复渲染
- **搜索结果缓存**：缓存热门查询的结果，提升响应速度

#### 增量更新
- **文件监听**：使用 `notify` 库监控文件系统变化
- **热重载**：在文档变更时增量更新 `DocumentTree`，而非完全重建

#### 索引优化
- **倒排索引**：将 `search_index` 重构为基于词汇的倒排索引
- **向量化搜索**：引入嵌入模型实现语义搜索能力

---

## 6. 设计优势与改进建议

### 6.1 设计优势

1. **单一职责原则**：模块专注于文档数据的管理与处理，职责清晰
2. **高内聚性**：相关功能（树构建、搜索、渲染）紧密组织在一起
3. **低耦合性**：通过明确定义的接口与其他模块交互
4. **可测试性**：纯函数式的 API 设计便于单元测试
5. **扩展性**：模块结构易于添加新功能（如标签系统、版本控制）

### 6.2 改进建议

1. **配置分离**：
   - 当前搜索权重硬编码在代码中
   - 建议提取为配置项，支持动态调整

2. **并发安全**：
   - `DocumentTree` 当前为不可变结构
   - 若需支持运行时更新，应考虑 `Arc<RwLock<T>>` 包装

3. **持久化支持**：
   - 可增加序列化/反序列化功能
   - 支持将构建好的 `DocumentTree` 缓存到磁盘，加速启动

4. **搜索功能增强**：
   - 支持布尔运算（AND/OR/NOT）
   - 添加正则表达式搜索选项
   - 实现模糊匹配功能

5. **国际化支持**：
   - 当前高亮实现假设为 ASCII 文本
   - 需要改进以正确处理 Unicode 和宽字符

---

## 7. 总结

文档数据域作为 Litho Book 系统的知识中枢，成功实现了从静态文件到动态知识库的转化。其设计充分体现了 Rust 语言的优势：通过强大的类型系统保证数据完整性，利用所有权机制确保内存安全，借助高性能的异步生态实现流畅的用户体验。

该模块不仅完成了基本的文档管理功能，还通过智能化的搜索算法和完善的上下文支持，为用户提供了超越传统文件浏览器的知识探索体验。其清晰的架构和模块化设计为未来的功能扩展奠定了坚实基础，是整个系统中最成熟、最关键的组成部分。