# é¡¹ç›®åˆ†ææ€»ç»“æŠ¥å‘Šï¼ˆå®Œæ•´ç‰ˆï¼‰

ç”Ÿæˆæ—¶é—´: 2025-10-04 09:16:59 UTC

## æ‰§è¡Œè€—æ—¶ç»Ÿè®¡

- **æ€»æ‰§è¡Œæ—¶é—´**: 589.59 ç§’
- **é¢„å¤„ç†é˜¶æ®µ**: 0.08 ç§’ (0.0%)
- **ç ”ç©¶é˜¶æ®µ**: 68.03 ç§’ (11.5%)
- **æ–‡æ¡£ç”Ÿæˆé˜¶æ®µ**: 521.49 ç§’ (88.4%)
- **è¾“å‡ºé˜¶æ®µ**: 0.00 ç§’ (0.0%)
- **Summaryç”Ÿæˆæ—¶é—´**: 0.000 ç§’

## ç¼“å­˜æ€§èƒ½ç»Ÿè®¡ä¸èŠ‚çº¦æ•ˆæœ

### æ€§èƒ½æŒ‡æ ‡
- **ç¼“å­˜å‘½ä¸­ç‡**: 100.0%
- **æ€»æ“ä½œæ¬¡æ•°**: 17
- **ç¼“å­˜å‘½ä¸­**: 17 æ¬¡
- **ç¼“å­˜æœªå‘½ä¸­**: 0 æ¬¡
- **ç¼“å­˜å†™å…¥**: 1 æ¬¡

### èŠ‚çº¦æ•ˆæœ
- **èŠ‚çœæ¨ç†æ—¶é—´**: 98.1 ç§’
- **èŠ‚çœTokenæ•°é‡**: 47817 è¾“å…¥ + 12612 è¾“å‡º = 60429 æ€»è®¡
- **ä¼°ç®—èŠ‚çœæˆæœ¬**: $0.0290
- **æ•ˆç‡æå‡æ¯”**: 0.2xï¼ˆèŠ‚çœæ—¶é—´ / å®é™…æ‰§è¡Œæ—¶é—´ï¼‰

## æ ¸å¿ƒè°ƒç ”æ•°æ®æ±‡æ€»

æ ¹æ®Promptæ¨¡æ¿æ•°æ®æ•´åˆè§„åˆ™ï¼Œä»¥ä¸‹ä¸ºå››ç±»è°ƒç ”ææ–™çš„å®Œæ•´å†…å®¹ï¼š

### ç³»ç»Ÿä¸Šä¸‹æ–‡è°ƒç ”æŠ¥å‘Š
æä¾›é¡¹ç›®çš„æ ¸å¿ƒç›®æ ‡ã€ç”¨æˆ·è§’è‰²å’Œç³»ç»Ÿè¾¹ç•Œä¿¡æ¯ã€‚

```json
{
  "business_value": "é€šè¿‡å°†æœ¬åœ°æ–‡æ¡£ç›®å½•è½¬åŒ–ä¸ºç»“æ„åŒ–ã€å¯æœç´¢ã€å¸¦AIè¾…åŠ©çš„Webç•Œé¢ï¼Œæ˜¾è‘—æå‡ä¸ªäººçŸ¥è¯†åº“çš„å¯è®¿é—®æ€§ä¸ä½¿ç”¨æ•ˆç‡ï¼Œå‡å°‘ä¿¡æ¯ç¢ç‰‡åŒ–ï¼Œæ”¯æŒé«˜æ•ˆçš„çŸ¥è¯†æ£€ç´¢ä¸å†…å®¹åˆ›ä½œï¼Œå°¤å…¶é€‚åˆæŠ€æœ¯æ–‡æ¡£ç®¡ç†ã€è¯»ä¹¦ç¬”è®°æ•´ç†å’ŒAIå¢å¼ºå‹å­¦ä¹ åœºæ™¯ã€‚",
  "confidence_score": 0.95,
  "external_systems": [
    {
      "description": "æä¾›AIèŠå¤©æµå¼å“åº”æœåŠ¡ï¼Œç”¨äºå¤„ç†ç”¨æˆ·åœ¨å‰ç«¯æå‡ºçš„æ–‡æ¡£ç›¸å…³é—®é¢˜",
      "interaction_type": "HTTP/REST",
      "name": "æ™ºè°±AI (ZhipuAI) OpenAIå…¼å®¹API"
    }
  ],
  "project_description": "Litho Book æ˜¯ä¸€ä¸ªå‘½ä»¤è¡Œå·¥å…·ä¸ Web æœåŠ¡ä¸€ä½“åŒ–çš„æœ¬åœ°æ–‡æ¡£æµè§ˆä¸AIåŠ©æ‰‹ç³»ç»Ÿï¼Œä¸“ä¸ºå¼€å‘è€…å’ŒçŸ¥è¯†å·¥ä½œè€…è®¾è®¡ï¼Œç”¨äºå°†æœ¬åœ° Markdown æ–‡æ¡£ç›®å½•è½¬æ¢ä¸ºå¯æœç´¢ã€å¯æµè§ˆçš„ Web åº”ç”¨ï¼Œå¹¶é›†æˆ AI èŠå¤©åŠŸèƒ½ä»¥å¢å¼ºçŸ¥è¯†æ¢ç´¢ä½“éªŒã€‚",
  "project_name": "litho-book",
  "project_type": "FullStackApp",
  "system_boundary": {
    "excluded_components": [
      "å‰ç«¯React/Vueç•Œé¢",
      "Markdownæ–‡ä»¶ç”Ÿæˆå·¥å…·",
      "æ–‡æ¡£ç‰ˆæœ¬æ§åˆ¶ï¼ˆå¦‚Gitï¼‰",
      "ç”¨æˆ·è®¤è¯ä¸æƒé™ç³»ç»Ÿ",
      "äº‘å­˜å‚¨åŒæ­¥æœåŠ¡",
      "AIæ¨¡å‹è®­ç»ƒæˆ–å¾®è°ƒ"
    ],
    "included_components": [
      "å‘½ä»¤è¡Œå‚æ•°è§£æ (cli.rs)",
      "æ–‡ä»¶ç³»ç»Ÿæ‰«æä¸æ–‡æ¡£æ ‘æ„å»º (filesystem.rs)",
      "ç»Ÿä¸€é”™è¯¯å¤„ç†æœºåˆ¶ (error.rs)",
      "Axum HTTP æœåŠ¡ç«¯ (server.rs)",
      "ä¸»ç¨‹åºå…¥å£åè°ƒ (main.rs)"
    ],
    "scope": "æœ¬åœ°æ–‡æ¡£æœåŠ¡å™¨ä¸AIå¢å¼ºå‹çŸ¥è¯†æ¢ç´¢ç³»ç»Ÿï¼Œä¸åŒ…å«å‰ç«¯UIå¼€å‘ã€æ–‡æ¡£ç”Ÿæˆã€æ–‡æ¡£åŒæ­¥æˆ–ç”¨æˆ·è´¦æˆ·ç®¡ç†åŠŸèƒ½"
  },
  "target_users": [
    {
      "description": "ä½¿ç”¨æœ¬åœ° Markdown æ–‡ä»¶ç®¡ç†ä»£ç æ–‡æ¡£ã€API æ³¨é‡Šã€æŠ€æœ¯ç¬”è®°çš„è½¯ä»¶å·¥ç¨‹å¸ˆ",
      "name": "å¼€å‘è€…",
      "needs": [
        "å¿«é€Ÿæµè§ˆæœ¬åœ°æ–‡æ¡£ç›®å½•",
        "å…¨æ–‡æœç´¢æ–‡æ¡£å†…å®¹",
        "åœ¨æµè§ˆå™¨ä¸­è·å¾—ç»“æ„åŒ–å±•ç¤º",
        "é€šè¿‡AIåŠ©æ‰‹æé—®æ–‡æ¡£ç›¸å…³å†…å®¹"
      ]
    },
    {
      "description": "éœ€è¦æ•´ç†å’Œæ£€ç´¢å¤§é‡ä¸ªäººç¬”è®°ã€è¯»ä¹¦æ‘˜è¦ã€ç ”ç©¶èµ„æ–™çš„å­¦è€…ã€ç ”ç©¶å‘˜æˆ–å†…å®¹åˆ›ä½œè€…",
      "name": "çŸ¥è¯†å·¥ä½œè€…",
      "needs": [
        "ç»Ÿä¸€ç®¡ç†åˆ†æ•£çš„ Markdown æ–‡ä»¶",
        "åŸºäºå…³é”®è¯å¿«é€Ÿå®šä½ä¿¡æ¯",
        "è·å¾—ä¸Šä¸‹æ–‡ç›¸å…³çš„AIé—®ç­”æ”¯æŒ",
        "ç¦»çº¿ä½¿ç”¨ï¼Œæ— éœ€äº‘ç«¯ä¸Šä¼ "
      ]
    }
  ]
}
```

### é¢†åŸŸæ¨¡å—è°ƒç ”æŠ¥å‘Š
æä¾›é«˜å±‚æ¬¡çš„é¢†åŸŸåˆ’åˆ†ã€æ¨¡å—å…³ç³»å’Œæ ¸å¿ƒä¸šåŠ¡æµç¨‹ä¿¡æ¯ã€‚

```json
{
  "architecture_summary": "Litho Book æ˜¯ä¸€ä¸ªé¢å‘æœ¬åœ°çŸ¥è¯†ç®¡ç†çš„å…¨æ ˆåº”ç”¨ï¼Œé‡‡ç”¨å‘½ä»¤è¡Œå¯åŠ¨ + Web æœåŠ¡æ¶æ„ï¼Œæ ¸å¿ƒè®¾è®¡éµå¾ªèŒè´£åˆ†ç¦»åŸåˆ™ã€‚ç³»ç»Ÿä»¥ Rust ç¼–å†™ï¼ŒåŸºäº Axum æ„å»ºé«˜æ€§èƒ½ HTTP æœåŠ¡ï¼Œé€šè¿‡ CLI è§£æç”¨æˆ·è¾“å…¥ï¼Œç”±ä¸»ç¨‹åºåè°ƒæ–‡ä»¶ç³»ç»Ÿæ‰«æã€é”™è¯¯å¤„ç†ä¸æœåŠ¡å¯åŠ¨ã€‚æ•´ä½“æ¶æ„æ¸…æ™°ï¼Œæ¨¡å—é—´ä¾èµ–æ˜ç¡®ï¼Œå¼ºè°ƒä½è€¦åˆä¸é«˜å†…èšï¼Œç‰¹åˆ«é’ˆå¯¹ Markdown æ–‡æ¡£çš„ç»“æ„åŒ–æµè§ˆä¸ AI å¢å¼ºæœç´¢è¿›è¡Œäº†æ·±åº¦ä¼˜åŒ–ï¼Œå…·å¤‡è‰¯å¥½çš„å¯ç»´æŠ¤æ€§ä¸æ‰©å±•æ€§ã€‚",
  "business_flows": [
    {
      "description": "ç”¨æˆ·é€šè¿‡å‘½ä»¤è¡Œå¯åŠ¨åº”ç”¨åï¼Œç³»ç»Ÿä»å‚æ•°è§£æå¼€å§‹ï¼Œå®Œæˆæ—¥å¿—åˆå§‹åŒ–ã€æ–‡æ¡£æ ‘æ„å»ºã€HTTP æœåŠ¡ç»‘å®šä¸è‡ªåŠ¨æµè§ˆå™¨æ‰“å¼€çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼Œæ˜¯ç”¨æˆ·é¦–æ¬¡ä½¿ç”¨ç³»ç»Ÿçš„å¿…ç»è·¯å¾„ã€‚",
      "entry_point": "å‘½ä»¤è¡Œæ‰§è¡Œ `litho-book --path ./docs --port 3000`",
      "importance": 10.0,
      "involved_domains_count": 3,
      "name": "é¡¹ç›®å¯åŠ¨ä¸æœåŠ¡åˆå§‹åŒ–æµç¨‹",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "é€šè¿‡ cli.rs è§£æå‘½ä»¤è¡Œå‚æ•°ï¼ŒéªŒè¯æ–‡æ¡£ç›®å½•ä¸ç«¯å£åˆæ³•æ€§",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç³»ç»Ÿæ”¯æ’‘åŸŸ",
          "operation": "åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿï¼Œæ‰“å°å¯åŠ¨æ¨ªå¹…",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "æ–‡æ¡£æ•°æ®åŸŸ",
          "operation": "è°ƒç”¨ filesystem.rs é€’å½’æ‰«ææ–‡æ¡£ç›®å½•ï¼Œæ„å»º DocumentTree å†…å­˜ç»“æ„",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç³»ç»Ÿæ”¯æ’‘åŸŸ",
          "operation": "åˆ›å»º Axum åº”ç”¨çŠ¶æ€ï¼ˆAppStateï¼‰ï¼Œç»‘å®šæ–‡æ¡£æ ‘ä¸è·¯ç”±å¤„ç†å™¨",
          "step": 4,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "å¯åŠ¨ Axum HTTP æœåŠ¡å™¨ï¼Œç»‘å®š TCP ç«¯å£",
          "step": 5,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç³»ç»Ÿæ”¯æ’‘åŸŸ",
          "operation": "æ ¹æ®é…ç½®å†³å®šæ˜¯å¦è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨è®¿é—®æœåŠ¡åœ°å€",
          "step": 6,
          "sub_module": null
        }
      ]
    },
    {
      "description": "ç”¨æˆ·åœ¨ Web ç•Œé¢è¾“å…¥å…³é”®è¯è¿›è¡Œæœç´¢ï¼Œç³»ç»Ÿåœ¨æ–‡æ¡£æ ‘ä¸­æ‰§è¡Œé«˜æ•ˆå…¨æ–‡æ£€ç´¢ï¼Œè¿”å›å¸¦é«˜äº®ä¸ç›¸å…³æ€§è¯„åˆ†çš„ç»“æœï¼Œæ˜¯çŸ¥è¯†å·¥ä½œè€…æœ€æ ¸å¿ƒçš„ä½¿ç”¨åœºæ™¯ã€‚",
      "entry_point": "å‰ç«¯å‘èµ· GET /search?q=å…³é”®è¯ è¯·æ±‚",
      "importance": 10.0,
      "involved_domains_count": 2,
      "name": "æ–‡æ¡£å…¨æ–‡æœç´¢æµç¨‹",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "Web æœåŠ¡æ¥æ”¶ /search è¯·æ±‚ï¼Œæå–æŸ¥è¯¢å…³é”®è¯",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "æ–‡æ¡£æ•°æ®åŸŸ",
          "operation": "åœ¨ DocumentTree ä¸­æ‰§è¡Œå…³é”®è¯åŒ¹é…ï¼Œç»“åˆæ ‡é¢˜æƒé‡ã€è¯é¢‘ä¸ä¸Šä¸‹æ–‡è¿›è¡Œç›¸å…³æ€§è¯„åˆ†",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "æ–‡æ¡£æ•°æ®åŸŸ",
          "operation": "å¯¹åŒ¹é…ç»“æœè¿›è¡Œæ’åºï¼Œæå–ä¸Šä¸‹æ–‡ç‰‡æ®µå¹¶æ·»åŠ  HTML é«˜äº®æ ‡ç­¾",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "å°†æœç´¢ç»“æœåºåˆ—åŒ–ä¸º JSON å¹¶è¿”å›å‰ç«¯",
          "step": 4,
          "sub_module": null
        }
      ]
    },
    {
      "description": "ç”¨æˆ·å‘ AI åŠ©æ‰‹æé—®ä¸æ–‡æ¡£ç›¸å…³çš„é—®é¢˜ï¼Œç³»ç»Ÿå°†ä¸Šä¸‹æ–‡ä¸å†å²å¯¹è¯æ‰“åŒ…ï¼Œè°ƒç”¨å¤–éƒ¨ AI API è·å–æµå¼å“åº”ï¼Œå¹¶ä»¥ SSE æ ¼å¼é€æ®µè¿”å›ï¼Œå®ç°è‡ªç„¶è¯­è¨€äº¤äº’ä½“éªŒã€‚",
      "entry_point": "å‰ç«¯å‘èµ· POST /chat è¯·æ±‚ï¼Œæºå¸¦å†å²ä¼šè¯ä¸é—®é¢˜",
      "importance": 9.0,
      "involved_domains_count": 3,
      "name": "AIåŠ©æ‰‹æµå¼å¯¹è¯æµç¨‹",
      "steps": [
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "Web æœåŠ¡æ¥æ”¶ /chat è¯·æ±‚ï¼Œæå–ç”¨æˆ·é—®é¢˜ä¸å¯¹è¯å†å²",
          "step": 1,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "æ–‡æ¡£æ•°æ®åŸŸ",
          "operation": "æ ¹æ®ä¸Šä¸‹æ–‡æ£€ç´¢ç›¸å…³æ–‡æ¡£ç‰‡æ®µï¼Œæ„å»ºåŒ…å«ç³»ç»Ÿæç¤ºè¯ä¸ä¸Šä¸‹æ–‡çš„ AI è¯·æ±‚å†…å®¹",
          "step": 2,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "é€šè¿‡ reqwest å‘æ™ºè°±AI OpenAI API å‘èµ·æµå¼ HTTP è¯·æ±‚",
          "step": 3,
          "sub_module": null
        },
        {
          "code_entry_point": null,
          "domain_module": "ç”¨æˆ·äº¤äº’åŸŸ",
          "operation": "å°† AI çš„æµå¼å“åº”è½¬æ¢ä¸º Server-Sent Events (SSE) æ ¼å¼ï¼Œé€å—è¿”å›å‰ç«¯",
          "step": 4,
          "sub_module": null
        }
      ]
    }
  ],
  "confidence_score": 0.98,
  "domain_modules": [
    {
      "code_paths": [
        "src/cli.rs",
        "src/server.rs"
      ],
      "complexity": 8.0,
      "description": "è´Ÿè´£å¤„ç†ç”¨æˆ·ä¸ç³»ç»Ÿçš„ç›´æ¥äº¤äº’ï¼ŒåŒ…æ‹¬å‘½ä»¤è¡Œå‚æ•°è§£æå’Œ Web ç•Œé¢çš„åç«¯æœåŠ¡æ”¯æŒã€‚è¯¥é¢†åŸŸæ˜¯ç”¨æˆ·è¿›å…¥ç³»ç»Ÿçš„å”¯ä¸€å…¥å£ï¼Œæ‰¿æ‹…é…ç½®æ¥æ”¶ã€å‚æ•°æ ¡éªŒä¸å‰ç«¯è¯·æ±‚å“åº”çš„æ ¸å¿ƒèŒè´£ï¼Œæ˜¯è¿æ¥ç”¨æˆ·æ„å›¾ä¸ç³»ç»Ÿèƒ½åŠ›çš„æ¡¥æ¢ã€‚",
      "domain_type": "æ ¸å¿ƒä¸šåŠ¡åŸŸ",
      "importance": 10.0,
      "name": "ç”¨æˆ·äº¤äº’åŸŸ",
      "sub_modules": [
        {
          "code_paths": [
            "src/cli.rs"
          ],
          "description": "è§£æç”¨æˆ·é€šè¿‡å‘½ä»¤è¡Œè¾“å…¥çš„æ–‡æ¡£è·¯å¾„ã€ç«¯å£ã€ä¸»æœºåœ°å€ç­‰é…ç½®å‚æ•°ï¼Œå¹¶è¿›è¡Œåˆæ³•æ€§æ ¡éªŒï¼ˆå¦‚ç›®å½•å­˜åœ¨æ€§ã€ç«¯å£æƒé™ï¼‰ï¼Œæ”¯æŒè·¨å¹³å°æƒé™æ£€æµ‹ã€‚",
          "importance": 9.0,
          "key_functions": [
            "è§£æ --pathã€--portã€--hostã€--openã€--verbose å‚æ•°",
            "éªŒè¯æ–‡æ¡£ç›®å½•æ˜¯å¦å­˜åœ¨ä¸”ä¸ºç›®å½•",
            "æ£€æµ‹ä½æƒé™ç«¯å£ï¼ˆ<1024ï¼‰çš„ç®¡ç†å‘˜æƒé™",
            "ç”ŸæˆæœåŠ¡åœ°å€å­—ç¬¦ä¸²"
          ],
          "name": "å‘½ä»¤è¡Œæ¥å£"
        },
        {
          "code_paths": [
            "src/server.rs"
          ],
          "description": "åŸºäº Axum æä¾› RESTful APIï¼Œå“åº”å‰ç«¯è¯·æ±‚ï¼ŒåŒ…æ‹¬æ–‡æ¡£æµè§ˆã€å…¨æ–‡æœç´¢ã€ç³»ç»Ÿç»Ÿè®¡ä¸ AI èŠå¤©æµå¼å“åº”ã€‚æ˜¯ç”¨æˆ·é€šè¿‡æµè§ˆå™¨ä¸ç³»ç»Ÿäº¤äº’çš„æ ¸å¿ƒé€šé“ã€‚",
          "importance": 10.0,
          "key_functions": [
            "æ¸²æŸ“ Markdown æ–‡ä»¶ä¸º HTML",
            "è¿”å›æ–‡æ¡£æ ‘ç»“æ„",
            "æ‰§è¡Œå…³é”®è¯å…¨æ–‡æœç´¢ï¼ˆå«åŠ æƒæ’åºï¼‰",
            "è¿”å›ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯ï¼ˆæ–‡ä»¶æ•°ã€å¤§å°ç­‰ï¼‰",
            "æµå¼å“åº” AI å¯¹è¯ï¼ˆSSEï¼‰",
            "ç”Ÿæˆé¦–é¡µ HTML æ¨¡æ¿"
          ],
          "name": "Web æœåŠ¡æ¥å£"
        }
      ]
    },
    {
      "code_paths": [
        "src/filesystem.rs"
      ],
      "complexity": 9.0,
      "description": "è´Ÿè´£æœ¬åœ°æ–‡æ¡£ç›®å½•çš„ç»“æ„åŒ–å»ºæ¨¡ä¸å†…å®¹ç®¡ç†ï¼Œå°†æ–‡ä»¶ç³»ç»Ÿä¸­çš„ Markdown æ–‡ä»¶è½¬æ¢ä¸ºå¯æœç´¢ã€å¯å¯¼èˆªçš„å†…å­˜æ ‘å½¢ç»“æ„ï¼ˆDocumentTreeï¼‰ï¼Œå¹¶æä¾›å…¨æ–‡æ£€ç´¢ä¸æ¸²æŸ“èƒ½åŠ›ã€‚æ˜¯ç³»ç»ŸçŸ¥è¯†å†…å®¹çš„æ ¸å¿ƒè½½ä½“ä¸å¤„ç†å¼•æ“ã€‚",
      "domain_type": "æ ¸å¿ƒä¸šåŠ¡åŸŸ",
      "importance": 10.0,
      "name": "æ–‡æ¡£æ•°æ®åŸŸ",
      "sub_modules": [
        {
          "code_paths": [
            "src/filesystem.rs"
          ],
          "description": "é€’å½’æ‰«ææŒ‡å®šç›®å½•ï¼Œæ„å»ºåŒ…å«æ–‡ä»¶è·¯å¾„ã€å…ƒæ•°æ®ä¸å†…å®¹çš„æ ‘å½¢ç»“æ„ï¼Œä»…ç´¢å¼• .md æ–‡ä»¶ï¼Œå¿½ç•¥éšè—æ–‡ä»¶ï¼Œæ”¯æŒæ–‡ä»¶ç±»å‹è¯†åˆ«ä¸è·¯å¾„æ˜ å°„ã€‚",
          "importance": 9.0,
          "key_functions": [
            "é€’å½’éå†ç›®å½•",
            "æ„å»º FileNode èŠ‚ç‚¹ä¸ DocumentTree ç»“æ„",
            "è¿‡æ»¤é Markdown æ–‡ä»¶ä¸éšè—æ–‡ä»¶",
            "å»ºç«‹æ–‡ä»¶è·¯å¾„åˆ°å†…å®¹çš„ç´¢å¼•"
          ],
          "name": "æ–‡æ¡£æ ‘æ„å»º"
        },
        {
          "code_paths": [
            "src/filesystem.rs"
          ],
          "description": "å®ç°åŸºäºå…³é”®è¯çš„æ™ºèƒ½æœç´¢ï¼Œç»“åˆæ ‡é¢˜æƒé‡ã€è¯é¢‘åˆ†æã€ä¸Šä¸‹æ–‡æå–ä¸ç›¸å…³æ€§æ’åºï¼Œè¿”å›å¸¦é«˜äº®çš„æœç´¢ç»“æœï¼Œæ”¯æŒå¿«é€Ÿå®šä½æ–‡æ¡£å†…å®¹ã€‚",
          "importance": 10.0,
          "key_functions": [
            "å…³é”®è¯åŒ¹é…ä¸é«˜äº®",
            "æ ‡é¢˜åŠ æƒï¼ˆH1/H2 ä¼˜å…ˆï¼‰",
            "è¯é¢‘ç»Ÿè®¡ä¸ç›¸å…³æ€§è¯„åˆ†",
            "ä¸Šä¸‹æ–‡ç‰‡æ®µæå–",
            "æœç´¢ç»“æœæ’åº"
          ],
          "name": "å…¨æ–‡æœç´¢å¼•æ“"
        },
        {
          "code_paths": [
            "src/filesystem.rs"
          ],
          "description": "å°† Markdown æºæ–‡ä»¶è½¬æ¢ä¸º HTML æ ¼å¼ï¼Œç”¨äºå‰ç«¯å±•ç¤ºï¼Œç¡®ä¿å†…å®¹åœ¨æµè§ˆå™¨ä¸­æ­£ç¡®å‘ˆç°ã€‚",
          "importance": 7.0,
          "key_functions": [
            "Markdown åˆ° HTML çš„è¯­æ³•è½¬æ¢",
            "ä»£ç å—é«˜äº®æ”¯æŒ",
            "å†…è”æ ·å¼ä¸ç»“æ„ä¿ç•™"
          ],
          "name": "Markdown æ¸²æŸ“å™¨"
        }
      ]
    },
    {
      "code_paths": [
        "src/main.rs",
        "src/error.rs"
      ],
      "complexity": 6.0,
      "description": "æä¾›ç³»ç»Ÿçº§é€šç”¨èƒ½åŠ›ï¼ŒåŒ…æ‹¬ç»Ÿä¸€é”™è¯¯å¤„ç†ã€æ—¥å¿—åˆå§‹åŒ–ã€ç¨‹åºå¯åŠ¨åè°ƒä¸å¤–éƒ¨æœåŠ¡è°ƒç”¨ã€‚è¯¥é¢†åŸŸä¸åŒ…å«ä¸šåŠ¡é€»è¾‘ï¼Œä½†ä¿éšœç³»ç»Ÿç¨³å®šè¿è¡Œä¸æ¨¡å—é—´é€šä¿¡çš„å¯é æ€§ã€‚",
      "domain_type": "åŸºç¡€è®¾æ–½åŸŸ",
      "importance": 8.0,
      "name": "ç³»ç»Ÿæ”¯æ’‘åŸŸ",
      "sub_modules": [
        {
          "code_paths": [
            "src/error.rs"
          ],
          "description": "å®šä¹‰ç»Ÿä¸€çš„ LithoBookError æšä¸¾ç±»å‹ï¼Œå°è£… IOã€åºåˆ—åŒ–ã€è·¯å¾„æ— æ•ˆç­‰é”™è¯¯ï¼Œå¹¶é€šè¿‡å®ç° From<LithoBookError> for axum::http::StatusCodeï¼Œå°†åº”ç”¨é”™è¯¯è‡ªåŠ¨æ˜ å°„ä¸ºæ ‡å‡† HTTP çŠ¶æ€ç ï¼Œå®ç°å‰åç«¯é”™è¯¯ä¸€è‡´æ€§ã€‚",
          "importance": 9.0,
          "key_functions": [
            "å®šä¹‰ LithoBookError æšä¸¾",
            "å°è£… std::io::Errorã€serde_json::Error",
            "æ˜ å°„ä¸º axum::http::StatusCode",
            "æä¾›é”™è¯¯è½¬æ¢ä¸æ—¥å¿—è®°å½•"
          ],
          "name": "é”™è¯¯å¤„ç†ä¸­æ¢"
        },
        {
          "code_paths": [
            "src/main.rs"
          ],
          "description": "ä½œä¸ºåº”ç”¨ä¸»å…¥å£ï¼Œè´Ÿè´£åˆå§‹åŒ–æ—¥å¿—ã€åŠ è½½é…ç½®ã€æ„å»ºæ–‡æ¡£æ ‘ã€åˆ›å»ºæœåŠ¡å™¨å¹¶å¯åŠ¨æœåŠ¡ï¼Œæ˜¯æ•´ä¸ªç³»ç»Ÿç”Ÿå‘½å‘¨æœŸçš„è°ƒåº¦ä¸­å¿ƒã€‚",
          "importance": 8.0,
          "key_functions": [
            "è§£æå‘½ä»¤è¡Œå‚æ•°",
            "åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ",
            "æ‰“å°å¯åŠ¨æ¨ªå¹…",
            "è°ƒç”¨ filesystem æ„å»ºæ–‡æ¡£æ ‘",
            "åˆ›å»º Axum è·¯ç”±å™¨ä¸ AppState",
            "ç»‘å®š TCP ç«¯å£å¹¶å¯åŠ¨ HTTP æœåŠ¡",
            "è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨"
          ],
          "name": "ç¨‹åºå¯åŠ¨åè°ƒ"
        }
      ]
    }
  ],
  "domain_relations": [
    {
      "description": "å‘½ä»¤è¡Œæ¥å£ä¸ Web æœåŠ¡æ¥å£å‡ä¾èµ–æ–‡æ¡£æ•°æ®åŸŸæä¾›çš„ DocumentTree ç»“æ„ï¼Œç”¨äºå“åº”ç”¨æˆ·è¯·æ±‚ã€‚CLI åœ¨å¯åŠ¨æ—¶è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿæ¨¡å—æ„å»ºæ ‘ï¼ŒWeb æœåŠ¡åœ¨æ¯æ¬¡æœç´¢æˆ–æµè§ˆæ—¶è®¿é—®è¯¥ç»“æ„ï¼Œæ˜¯ç³»ç»Ÿæœ€æ ¸å¿ƒçš„æ•°æ®æµä¾èµ–ã€‚",
      "from_domain": "ç”¨æˆ·äº¤äº’åŸŸ",
      "relation_type": "æ•°æ®ä¾èµ–",
      "strength": 9.0,
      "to_domain": "æ–‡æ¡£æ•°æ®åŸŸ"
    },
    {
      "description": "CLI ä¸ Web æœåŠ¡åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ä¾èµ–ç³»ç»Ÿæ”¯æ’‘åŸŸçš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œå°†ä¸šåŠ¡é”™è¯¯ç»Ÿä¸€è½¬æ¢ä¸ºæ ‡å‡† HTTP å“åº”ç ï¼Œç¡®ä¿ç”¨æˆ·è·å¾—ä¸€è‡´çš„é”™è¯¯åé¦ˆã€‚",
      "from_domain": "ç”¨æˆ·äº¤äº’åŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 8.0,
      "to_domain": "ç³»ç»Ÿæ”¯æ’‘åŸŸ"
    },
    {
      "description": "ä¸»ç¨‹åºå…¥å£ï¼ˆmain.rsï¼‰ä½œä¸ºå¯åŠ¨åè°ƒè€…ï¼Œä¸»åŠ¨è°ƒç”¨ CLI æ¨¡å—è§£æå‚æ•°ã€è°ƒç”¨ filesystem æ„å»ºæ–‡æ¡£æ ‘ã€è°ƒç”¨ server å¯åŠ¨ HTTP æœåŠ¡ï¼Œæ˜¯æ•´ä¸ªç³»ç»Ÿæµç¨‹çš„å‘èµ·è€…ä¸è°ƒåº¦è€…ã€‚",
      "from_domain": "ç³»ç»Ÿæ”¯æ’‘åŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 9.0,
      "to_domain": "ç”¨æˆ·äº¤äº’åŸŸ"
    },
    {
      "description": "æ–‡æ¡£æ•°æ®åŸŸåœ¨æ‰«ææ–‡ä»¶æˆ–æ¸²æŸ“ Markdown æ—¶å¯èƒ½è§¦å‘ IO é”™è¯¯ï¼Œéœ€é€šè¿‡ error.rs ç»Ÿä¸€è½¬æ¢ä¸º LithoBookErrorï¼Œå®ç°é”™è¯¯çš„æ ‡å‡†åŒ–ä¼ é€’ã€‚",
      "from_domain": "æ–‡æ¡£æ•°æ®åŸŸ",
      "relation_type": "æ•°æ®ä¾èµ–",
      "strength": 7.0,
      "to_domain": "ç³»ç»Ÿæ”¯æ’‘åŸŸ"
    },
    {
      "description": "Web æœåŠ¡æ¥å£åœ¨å¤„ç† AI èŠå¤©è¯·æ±‚æ—¶ï¼Œé€šè¿‡ reqwest å‘æ™ºè°±AIçš„ OpenAI å…¼å®¹ API å‘èµ· HTTP è¯·æ±‚ï¼Œè·å–æµå¼å“åº”å¹¶è½¬æ¢ä¸º SSE æµè¿”å›å‰ç«¯ï¼Œæ˜¯ç³»ç»Ÿå¢å¼ºåŠŸèƒ½çš„å…³é”®å¤–éƒ¨ä¾èµ–ã€‚",
      "from_domain": "ç”¨æˆ·äº¤äº’åŸŸ",
      "relation_type": "æœåŠ¡è°ƒç”¨",
      "strength": 8.0,
      "to_domain": "å¤–éƒ¨ç³»ç»Ÿ"
    }
  ]
}
```

### å·¥ä½œæµè°ƒç ”æŠ¥å‘Š
åŒ…å«å¯¹ä»£ç åº“çš„é™æ€åˆ†æç»“æœå’Œä¸šåŠ¡æµç¨‹åˆ†æã€‚

```json
{
  "main_workflow": {
    "description": "ç”¨æˆ·é€šè¿‡å‘½ä»¤è¡Œå¯åŠ¨åº”ç”¨åï¼Œç³»ç»Ÿä»å‚æ•°è§£æå¼€å§‹ï¼Œå®Œæˆæ—¥å¿—åˆå§‹åŒ–ã€æ–‡æ¡£æ ‘æ„å»ºã€HTTP æœåŠ¡ç»‘å®šä¸è‡ªåŠ¨æµè§ˆå™¨æ‰“å¼€çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼Œæ˜¯ç”¨æˆ·é¦–æ¬¡ä½¿ç”¨ç³»ç»Ÿçš„å¿…ç»è·¯å¾„ã€‚",
    "flowchart_mermaid": "graph TD\n    A[ç”¨æˆ·æ‰§è¡Œå‘½ä»¤è¡Œå¯åŠ¨] --> B[è§£æå‘½ä»¤è¡Œå‚æ•°]\n    B --> C[åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ]\n    C --> D[æ„å»ºæ–‡æ¡£æ ‘]\n    D --> E[åˆ›å»º HTTP æœåŠ¡å™¨]\n    E --> F[å¯åŠ¨ HTTP æœåŠ¡]\n    F --> G[è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨]",
    "name": "é¡¹ç›®å¯åŠ¨ä¸æœåŠ¡åˆå§‹åŒ–æµç¨‹"
  },
  "other_important_workflows": [
    {
      "description": "ç”¨æˆ·åœ¨ Web ç•Œé¢è¾“å…¥å…³é”®è¯è¿›è¡Œæœç´¢ï¼Œç³»ç»Ÿåœ¨æ–‡æ¡£æ ‘ä¸­æ‰§è¡Œé«˜æ•ˆå…¨æ–‡æ£€ç´¢ï¼Œè¿”å›å¸¦é«˜äº®ä¸ç›¸å…³æ€§è¯„åˆ†çš„ç»“æœï¼Œæ˜¯çŸ¥è¯†å·¥ä½œè€…æœ€æ ¸å¿ƒçš„ä½¿ç”¨åœºæ™¯ã€‚",
      "flowchart_mermaid": "graph TD\n    A[ç”¨æˆ·è¾“å…¥æœç´¢å…³é”®è¯] --> B[æ¥æ”¶æœç´¢è¯·æ±‚]\n    B --> C[æ‰§è¡Œå…¨æ–‡æ£€ç´¢]\n    C --> D[æ’åºå¹¶é«˜äº®ç»“æœ]\n    D --> E[è¿”å›æœç´¢ç»“æœ]",
      "name": "æ–‡æ¡£å…¨æ–‡æœç´¢æµç¨‹"
    },
    {
      "description": "ç”¨æˆ·å‘ AI åŠ©æ‰‹æé—®ä¸æ–‡æ¡£ç›¸å…³çš„é—®é¢˜ï¼Œç³»ç»Ÿå°†ä¸Šä¸‹æ–‡ä¸å†å²å¯¹è¯æ‰“åŒ…ï¼Œè°ƒç”¨å¤–éƒ¨ AI API è·å–æµå¼å“åº”ï¼Œå¹¶ä»¥ SSE æ ¼å¼é€æ®µè¿”å›ï¼Œå®ç°è‡ªç„¶è¯­è¨€äº¤äº’ä½“éªŒã€‚",
      "flowchart_mermaid": "graph TD\n    A[ç”¨æˆ·æäº¤é—®é¢˜] --> B[æ¥æ”¶èŠå¤©è¯·æ±‚]\n    B --> C[æ„å»º AI è¯·æ±‚å†…å®¹]\n    C --> D[è°ƒç”¨ AI API]\n    D --> E[æµå¼è¿”å›å“åº”]",
      "name": "AIåŠ©æ‰‹æµå¼å¯¹è¯æµç¨‹"
    }
  ]
}
```

### ä»£ç æ´å¯Ÿæ•°æ®
æ¥è‡ªé¢„å¤„ç†é˜¶æ®µçš„ä»£ç åˆ†æç»“æœï¼ŒåŒ…å«å‡½æ•°ã€ç±»å’Œæ¨¡å—çš„å®šä¹‰ã€‚

```json
[
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "src/main.rs",
      "functions": [
        "main",
        "init_logging",
        "print_banner",
        "open_browser",
        "format_bytes"
      ],
      "importance_score": 1.0,
      "interfaces": [],
      "name": "main.rs",
      "source_summary": "mod cli;\nmod error;\nmod filesystem;\nmod server;\n\nuse clap::Parser;\nuse tracing::{error, info, warn};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Parse command line arguments\n    let args = cli::Args::parse();\n    \n    // Initialize logging\n    init_logging(args.verbose);\n    \n    // Print banner\n    print_banner();\n    \n    // Validate arguments\n    if let Err(e) = args.validate() {\n        error!(\"å‚æ•°éªŒè¯å¤±è´¥: {}\", e);\n        std::process::exit(1);\n    }\n    \n    info!(\"æ­£åœ¨æ‰«ææ–‡æ¡£ç›®å½•: {}\", args.docs_dir.display());\n    \n    // Build document tree\n    let doc_tree = match filesystem::DocumentTree::new(&args.docs_dir) {\n        Ok(tree) => {\n            let stats = tree.get_stats();\n            info!(\n                \"æˆåŠŸæ‰«ææ–‡æ¡£ç›®å½•: {} ä¸ªæ–‡ä»¶, {} ä¸ªç›®å½•, æ€»å¤§å°: {}\",\n                stats.total_files,\n                stats.total_dirs,\n                format_bytes(stats.total_size)\n            );\n            \n            if stats.total_files == 0 {\n                warn!(\"æœªæ‰¾åˆ°ä»»ä½• Markdown æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥ç›®å½•æ˜¯å¦åŒ…å« .md æ–‡ä»¶\");\n            }\n            \n            tree\n        }\n        Err(e) => {\n            error!(\"æ‰«ææ–‡æ¡£ç›®å½•å¤±è´¥: {}\", e);\n            std::process::exit(1);\n        }\n    };\n    \n    // Create router\n    let docs_path = args.docs_dir.display().to_string().replace('\\\\', \"/\");\n    let app = server::create_router(doc_tree, docs_path);\n    \n    // Start server\n    let bind_address = args.bind_address();\n    let listener = match tokio::net::TcpListener::bind(&bind_address).await {\n        Ok(listener) => {\n            info!(\"æœåŠ¡å™¨ç»‘å®šæˆåŠŸ: {}\", bind_address);\n            listener\n        }\n        Err(e) => {\n            error!(\"æ— æ³•ç»‘å®šåˆ°åœ°å€ {}: {}\", bind_address, e);\n            std::process::exit(1);\n        }\n    };\n    \n    let server_url = args.server_url();\n    \n    info!(\"ğŸš€ Litho Book æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ!\");\n    info!(\"ğŸ“– è®¿é—®åœ°å€: {}\", server_url);\n    info!(\"ğŸ“ æ–‡æ¡£ç›®å½•: {}\", args.docs_dir.display());\n    info!(\"â¹ï¸  æŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨\");\n    \n    // Auto-open browser\n    if args.open {\n        info!(\"æ­£åœ¨æ‰“å¼€æµè§ˆå™¨...\");\n        if let Err(e) = open_browser(&server_url) {\n            warn!(\"æ— æ³•è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨: {}\", e);\n            info!(\"è¯·æ‰‹åŠ¨è®¿é—®: {}\", server_url);\n        }\n    }\n    \n    // Start server\n    if let Err(e) = axum::serve(listener, app).await {\n        error!(\"æœåŠ¡å™¨è¿è¡Œé”™è¯¯: {}\", e);\n        std::process::exit(1);\n    }\n    \n    Ok(())\n}\n\n/// Initialize logging based on verbosity level\nfn init_logging(verbose: bool) {\n    let filter = if verbose {\n        tracing_subscriber::filter::LevelFilter::DEBUG\n    } else {\n        tracing_subscriber::filter::LevelFilter::INFO\n    };\n    \n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::fmt::layer()\n                .with_target(false)\n                .with_thread_ids(false)\n                .with_thread_names(false)\n                .with_file(false)\n                .with_line_number(false)\n        )\n        .with(filter)\n        .init();\n}\n\n/// Print application banner\nfn print_banner() {\n    println!();\n    println!(\"ğŸ“š Litho Book - Documentation Reader\");\n    println!(\"   Version: {}\", env!(\"CARGO_PKG_VERSION\"));\n    println!(\"   A web-based reader for litho-generated documentation\");\n    println!();\n}\n\n/// Open browser automatically\nfn open_browser(url: &str) -> anyhow::Result<()> {\n    #[cfg(target_os = \"windows\")]\n    {\n        std::process::Command::new(\"cmd\")\n            .args([\"/c\", \"start\", \"\", url])\n            .spawn()?;\n    }\n    \n    #[cfg(target_os = \"macos\")]\n    {\n        std::process::Command::new(\"open\")\n            .arg(url)\n            .spawn()?;\n    }\n    \n    #[cfg(target_os = \"linux\")]\n    {\n        // Try different browsers in order of preference\n        let browsers = [\"xdg-open\", \"firefox\", \"chromium\", \"google-chrome\"];\n        \n        for browser in &browsers {\n            if std::process::Command::new(browser)\n                .arg(url)\n                .spawn()\n                .is_ok()\n            {\n                return Ok(());\n            }\n        }\n        \n        anyhow::bail!(\"No suitable browser found\");\n    }\n    \n    #[cfg(not(any(target_os = \"windows\", target_os = \"macos\", target_os = \"linux\")))]\n    {\n        anyhow::bail!(\"Automatic browser opening not supported on this platform\");\n    }\n    \n    Ok(())\n}\n\n/// Format bytes into human-readable format\nfn format_bytes(bytes: u64) -> String {\n    const UNITS: &[&str] = &[\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n    \n    if bytes == 0 {\n        return \"0 B\".to_string();\n    }\n    \n    let mut size = bytes as f64;\n    let mut unit_index = 0;\n    \n    while size >= 1024.0 && unit_index < UNITS.len() - 1 {\n        size /= 1024.0;\n        unit_index += 1;\n    }\n    \n    if unit_index == 0 {\n        format!(\"{} {}\", bytes, UNITS[unit_index])\n    } else {\n        format!(\"{:.1} {}\", size, UNITS[unit_index])\n    }\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.9,
      "coupling_factor": 0.8,
      "cyclomatic_complexity": 15.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 187,
      "number_of_classes": 0,
      "number_of_functions": 5
    },
    "dependencies": [
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 11,
        "name": "cli",
        "path": "./src/cli.rs",
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 11,
        "name": "error",
        "path": "./src/error.rs",
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 11,
        "name": "filesystem",
        "path": "./src/filesystem.rs",
        "version": null
      },
      {
        "dependency_type": "internal",
        "is_external": false,
        "line_number": 11,
        "name": "server",
        "path": "./src/server.rs",
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 12,
        "name": "clap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 13,
        "name": "tracing",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 13,
        "name": "tracing_subscriber",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 15,
        "name": "tokio",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 15,
        "name": "anyhow",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 56,
        "name": "axum",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 23,
        "name": "std::process",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 106,
        "name": "std::fs",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "external",
        "is_external": true,
        "line_number": 73,
        "name": "open",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "main.rs æ˜¯ Litho Book é¡¹ç›®çš„æ‰§è¡Œå…¥å£ï¼Œè´Ÿè´£åˆå§‹åŒ–åº”ç”¨ç¯å¢ƒã€è§£æå‘½ä»¤è¡Œå‚æ•°ã€æ„å»ºæ–‡æ¡£æ ‘ã€å¯åŠ¨ Web æœåŠ¡å™¨å¹¶å¤„ç†ç³»ç»Ÿçº§æ“ä½œã€‚å®ƒåè°ƒå¤šä¸ªæ¨¡å—ï¼ˆcliã€errorã€filesystemã€serverï¼‰çš„å·¥ä½œæµç¨‹ï¼Œå®Œæˆä»ç”¨æˆ·è¾“å…¥åˆ°æœåŠ¡å¯åŠ¨çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸã€‚æ ¸å¿ƒæµç¨‹åŒ…æ‹¬ï¼šè§£æå‘½ä»¤è¡Œå‚æ•°ã€åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿã€æ‰“å°å¯åŠ¨æ¨ªå¹…ã€éªŒè¯å‚æ•°åˆæ³•æ€§ã€æ‰«ææ–‡æ¡£ç›®å½•æ„å»ºæ–‡ä»¶æ ‘ã€åˆ›å»º Axum è·¯ç”±å™¨ã€ç»‘å®š TCP ç›‘å¬ç«¯å£ã€å¯åŠ¨ HTTP æœåŠ¡ï¼Œå¹¶åœ¨å¿…è¦æ—¶è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ã€‚è¯¥ç»„ä»¶æ˜¯æ•´ä¸ªåº”ç”¨çš„å¯åŠ¨ä¸­æ¢ï¼Œä¸åŒ…å«ä¸šåŠ¡é€»è¾‘å®ç°ï¼Œè€Œæ˜¯ä½œä¸ºåè°ƒè€…å°†ä»»åŠ¡å§”æ‰˜ç»™å…¶ä»–æ¨¡å—ã€‚",
    "interfaces": [],
    "responsibilities": [
      "è§£æå’ŒéªŒè¯å‘½ä»¤è¡Œå‚æ•°",
      "åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿä¸ç¯å¢ƒé…ç½®",
      "æ„å»ºæ–‡æ¡£ç›®å½•æ ‘å¹¶å¤„ç†æ–‡ä»¶æ‰«æ",
      "åˆ›å»ºå¹¶å¯åŠ¨ Axum HTTP æœåŠ¡å™¨",
      "å¤„ç†å¹³å°ç›¸å…³çš„æµè§ˆå™¨è‡ªåŠ¨æ‰“å¼€é€»è¾‘"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": null,
      "file_path": "src/filesystem.rs",
      "functions": [
        "FileNode",
        "SearchResult",
        "SearchMatch",
        "DocumentTree",
        "TreeStats",
        "DocumentTree::new",
        "DocumentTree::build_tree",
        "DocumentTree::get_file_content",
        "DocumentTree::render_markdown",
        "DocumentTree::get_stats",
        "DocumentTree::search_content",
        "DocumentTree::highlight_matches"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "filesystem.rs",
      "source_summary": "use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse tracing::{debug, warn};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FileNode {\n    pub name: String,\n    pub path: String,\n    pub is_file: bool,\n    pub children: Vec<FileNode>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub size: Option<u64>,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub modified: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct SearchResult {\n    pub file_path: String,\n    pub file_name: String,\n    pub title: Option<String>,\n    pub matches: Vec<SearchMatch>,\n    pub relevance_score: f32,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct SearchMatch {\n    pub line_number: usize,\n    pub content: String,\n    pub highlighted_content: String,\n    pub context_before: Option<String>,\n    pub context_after: Option<String>,\n}\n\n#[derive(Debug, Clone)]\npub struct DocumentTree {\n    pub root: FileNode,\n    pub file_map: HashMap<String, PathBuf>,\n    pub stats: TreeStats,\n    pub search_index: HashMap<String, Vec<String>>, // file_path -> lines\n}\n\n#[derive(Debug, Clone)]\npub struct TreeStats {\n    pub total_files: usize,\n    pub total_dirs: usize,\n    pub total_size: u64,\n}\n\nimpl DocumentTree {\n    /// Create a new document tree from the given directory\n    pub fn new(docs_dir: &Path) -> anyhow::Result<Self> {\n        let mut file_map = HashMap::new();\n        let mut search_index = HashMap::new();\n        let mut stats = TreeStats {\n            total_files: 0,\n            total_dirs: 0,\n            total_size: 0,\n        };\n\n        debug!(\"Building document tree from: {}\", docs_dir.display());\n\n        // Create a virtual root that contains the children of the actual directory\n        let mut children = Vec::new();\n\n        // Read directory contents and sort them\n        let mut entries: Vec<_> = std::fs::read_dir(docs_dir)?\n            .filter_map(|entry| entry.ok())\n            .collect();\n\n        // Sort entries: directories first, then files, both alphabetically\n        entries.sort_by(|a, b| {\n            let a_is_dir = a.path().is_dir();\n            let b_is_dir = b.path().is_dir();\n\n            match (a_is_dir, b_is_dir) {\n                (true, false) => std::cmp::Ordering::Less, // Directories first\n                (false, true) => std::cmp::Ordering::Greater, // Files second\n                _ => a.file_name().cmp(&b.file_name()),    // Same type: sort by name\n            }\n        });\n\n        for entry in entries {\n            let path = entry.path();\n\n            // Skip hidden files and non-markdown files (unless it's a directory)\n            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                if name.starts_with('.') {\n                    debug!(\"Skipping hidden file/directory: {}\", name);\n                    continue;\n                }\n\n                if path.is_file() && path.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n                    debug!(\"Skipping non-markdown file: {}\", name);\n                    continue;\n                }\n            }\n\n            match Self::build_tree(\n                &path,\n                docs_dir,\n                &mut file_map,\n                &mut search_index,\n                &mut stats,\n            ) {\n                Ok(child) => children.push(child),\n                Err(e) => {\n                    warn!(\"Failed to process path {}: {}\", path.display(), e);\n                    continue;\n                }\n            }\n        }\n\n        // Create virtual root node\n        let root = FileNode {\n            name: \"root\".to_string(),\n            path: \"\".to_string(),\n            is_file: false,\n            children,\n            size: None,\n            modified: None,\n        };\n\n        debug!(\n            \"Document tree built: {} files, {} directories, {} bytes total\",\n            stats.total_files, stats.total_dirs, stats.total_size\n        );\n\n        Ok(DocumentTree {\n            root,\n            file_map,\n            stats,\n            search_index,\n        })\n    }\n\n    /// Recursively build the file tree\n    fn build_tree(\n        current_path: &Path,\n        base_path: &Path,\n        file_map: &mut HashMap<String, PathBuf>,\n        search_index: &mut HashMap<String, Vec<String>>,\n        stats: &mut TreeStats,\n    ) -> anyhow::Result<FileNode> {\n        let name = current_path\n            .file_name()\n            .unwrap_or_default()\n            .to_string_lossy()\n            .to_string();\n\n        let relative_path = current_path\n            .strip_prefix(base_path)\n            .unwrap_or(current_path)\n            .to_string_lossy()\n            .replace('\\\\', \"/\");\n\n        if current_path.is_file() {\n            let metadata = std::fs::metadata(current_path)?;\n            let size = metadata.len();\n            let modified = metadata.modified().ok().and_then(|time| {\n                time.duration_since(std::time::UNIX_EPOCH)\n                    .ok()\n                    .map(|d| {\n                        let datetime = chrono::DateTime::from_timestamp(d.as_secs() as i64, 0)?;\n                        Some(datetime.format(\"%Y-%m-%d %H:%M:%S\").to_string())\n                    })\n                    .flatten()\n            });\n\n            if current_path.extension().and_then(|s| s.to_str()) == Some(\"md\") {\n                file_map.insert(relative_path.clone(), current_path.to_path_buf());\n\n                // Build search index for this file\n                if let Ok(content) = std::fs::read_to_string(current_path) {\n                    let lines: Vec<String> = content.lines().map(|line| line.to_string()).collect();\n                    search_index.insert(relative_path.clone(), lines);\n                }\n\n                stats.total_files += 1;\n                stats.total_size += size;\n            }\n\n            return Ok(FileNode {\n                name,\n                path: relative_path,\n                is_file: true,\n                children: vec![],\n                size: Some(size),\n                modified,\n            });\n        }\n\n        stats.total_dirs += 1;\n        let mut children = Vec::new();\n\n        // Read directory contents and sort them\n        let mut entries: Vec<_> = std::fs::read_dir(current_path)?\n            .filter_map(|entry| entry.ok())\n            .collect();\n\n        // Sort entries: directories first, then files, both alphabetically\n        entries.sort_by(|a, b| {\n            let a_is_dir = a.path().is_dir();\n            let b_is_dir = b.path().is_dir();\n\n            match (a_is_dir, b_is_dir) {\n                (true, false) => std::cmp::Ordering::Less, // Directories first\n                (false, true) => std::cmp::Ordering::Greater, // Files second\n                _ => {\n                    // Same type: sort by name (case-insensitive)\n                    let a_name = a.file_name().to_string_lossy().to_lowercase();\n                    let b_name = b.file_name().to_string_lossy().to_lowercase();\n                    a_name.cmp(&b_name)\n                }\n            }\n        });\n\n        for entry in entries {\n            let path = entry.path();\n\n            // Skip hidden files and non-markdown files (unless it's a directory)\n            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                if name.starts_with('.') {\n                    debug!(\"Skipping hidden file/directory: {}\", name);\n                    continue;\n                }\n\n                if path.is_file() && path.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n                    debug!(\"Skipping non-markdown file: {}\", name);\n                    continue;\n                }\n            }\n\n            match Self::build_tree(&path, base_path, file_map, search_index, stats) {\n                Ok(child) => children.push(child),\n                Err(e) => {\n                    warn!(\"Failed to process path {}: {}\", path.display(), e);\n                    continue;\n                }\n            }\n        }\n\n        Ok(FileNode {\n            name,\n            path: relative_path,\n            is_file: false,\n            children,\n            size: None,\n            modified: None,\n        })\n    }\n\n    /// Get the content of a file by its relative path\n    pub fn get_file_content(&self, file_path: &str) -> anyhow::Result<String> {\n        let path = self\n            .file_map\n            .get(file_path)\n            .ok_or_else(|| anyhow::anyhow!(\"File not found: {}\", file_path))?;\n\n        debug!(\"Reading file: {}\", path.display());\n        let content = std::fs::read_to_string(path)\n            .map_err(|e| anyhow::anyhow!(\"Failed to read file {}: {}\", path.display(), e))?;\n\n        Ok(content)\n    }\n\n    /// Render markdown content to HTML\n    pub fn render_markdown(&self, content: &str) -> String {\n        use pulldown_cmark::{Options, Parser, html};\n\n        let mut options = Options::empty();\n        options.insert(Options::ENABLE_TABLES);\n        options.insert(Options::ENABLE_FOOTNOTES);\n        options.insert(Options::ENABLE_STRIKETHROUGH);\n        options.insert(Options::ENABLE_TASKLISTS);\n        options.insert(Options::ENABLE_SMART_PUNCTUATION);\n        options.insert(Options::ENABLE_HEADING_ATTRIBUTES);\n\n        let parser = Parser::new_ext(content, options);\n        let mut html_output = String::new();\n        html::push_html(&mut html_output, parser);\n\n        html_output\n    }\n\n    /// Get statistics about the document tree\n    pub fn get_stats(&self) -> &TreeStats {\n        &self.stats\n    }\n\n    /// Advanced search with full-text search and content preview\n    pub fn search_content(&self, query: &str) -> Vec<SearchResult> {\n        if query.trim().is_empty() {\n            return vec![];\n        }\n\n        let query_lower = query.to_lowercase();\n        let mut results = Vec::new();\n\n        for (file_path, lines) in &self.search_index {\n            let mut matches = Vec::new();\n            let mut relevance_score = 0.0;\n\n            // Extract title from first heading\n            let title = lines\n                .iter()\n                .find(|line| line.trim().starts_with('#'))\n                .map(|line| line.trim_start_matches('#').trim().to_string());\n\n            // Search through all lines\n            for (line_number, line) in lines.iter().enumerate() {\n                let line_lower = line.to_lowercase();\n\n                if line_lower.contains(&query_lower) {\n                    // Calculate relevance score\n                    let mut line_score = 1.0;\n\n                    // Higher score for title matches\n                    if line.trim().starts_with('#') {\n                        line_score *= 3.0;\n                    }\n\n                    // Higher score for exact word matches\n                    if line_lower\n                        .split_whitespace()\n                        .any(|word| word == query_lower)\n                    {\n                        line_score *= 2.0;\n                    }\n\n                    // Higher score for matches at the beginning of the line\n                    if line_lower.trim_start().starts_with(&query_lower) {\n                        line_score *= 1.5;\n                    }\n\n                    relevance_score += line_score;\n\n                    // Create highlighted content\n                    let highlighted_content = self.highlight_matches(line, query);\n\n                    // Get context lines\n                    let context_before = if line_number > 0 {\n                        lines.get(line_number - 1).cloned()\n                    } else {\n                        None\n                    };\n\n                    let context_after = lines.get(line_number + 1).cloned();\n\n                    matches.push(SearchMatch {\n                        line_number: line_number + 1, // 1-based line numbers\n                        content: line.clone(),\n                        highlighted_content,\n                        context_before,\n                        context_after,\n                    });\n                }\n            }\n\n            // Also check filename matches\n            let file_name = file_path.split('/').last().unwrap_or(file_path);\n            if file_name.to_lowercase().contains(&query_lower) {\n                relevance_score += 2.0; // Bonus for filename matches\n            }\n\n            if !matches.is_empty() {\n                results.push(SearchResult {\n                    file_path: file_path.clone(),\n                    file_name: file_name.to_string(),\n                    title,\n                    matches,\n                    relevance_score,\n                });\n            }\n        }\n\n        // Sort by relevance score (descending)\n        results.sort_by(|a, b| {\n            b.relevance_score\n                .partial_cmp(&a.relevance_score)\n                .unwrap_or(std::cmp::Ordering::Equal)\n        });\n\n        // Limit results to prevent overwhelming the UI\n        results.truncate(50);\n\n        results\n    }\n\n    /// Highlight search matches in content\n    fn highlight_matches(&self, content: &str, query: &str) -> String {\n        let query_lower = query.to_lowercase();\n        let content_lower = content.to_lowercase();\n\n        if let Some(start) = content_lower.find(&query_lower) {\n            let end = start + query.len();\n            let before = &content[..start];\n            let matched = &content[start..end];\n            let after = &content[end..];\n\n            format!(\"{}<mark>{}</mark>{}\", before, matched, after)\n        } else {\n            content.to_string()\n        }\n    }\n}\n"
    },
    "complexity_metrics": {
      "cohesion_score": 0.85,
      "coupling_factor": 0.65,
      "cyclomatic_complexity": 34.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 407,
      "number_of_classes": 5,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": false,
        "line_number": null,
        "name": "std::collections::HashMap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": false,
        "line_number": null,
        "name": "std::path::{Path, PathBuf}",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "tracing",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "filesystem.rs æ˜¯ä¸€ä¸ªç”¨äºæ„å»ºå’Œç®¡ç†æ–‡æ¡£ç›®å½•æ ‘çš„æ¨¡å‹ç»„ä»¶ï¼Œæ ¸å¿ƒåŠŸèƒ½æ˜¯é€’å½’æ‰«ææŒ‡å®šç›®å½•ï¼Œå°†æ–‡ä»¶ç³»ç»Ÿç»“æ„è½¬æ¢ä¸ºå†…å­˜ä¸­çš„æ ‘å½¢æ•°æ®ç»“æ„ï¼ˆDocumentTreeï¼‰ï¼Œå¹¶æ”¯æŒå…¨æ–‡æœç´¢ã€Markdown æ¸²æŸ“å’Œæ–‡ä»¶å†…å®¹è¯»å–ã€‚å®ƒå°†æ–‡ä»¶ç³»ç»Ÿä¸­çš„æ–‡ä»¶å’Œç›®å½•æŠ½è±¡ä¸º FileNode èŠ‚ç‚¹ï¼Œå¹¶é€šè¿‡ DocumentTree ç»Ÿä¸€ç®¡ç†æ–‡ä»¶è·¯å¾„æ˜ å°„ã€æœç´¢ç´¢å¼•å’Œç»Ÿè®¡ä¿¡æ¯ã€‚è¯¥ç»„ä»¶ç‰¹åˆ«é’ˆå¯¹ Markdown æ–‡ä»¶è¿›è¡Œä¼˜åŒ–ï¼Œä»…ç´¢å¼• .md æ–‡ä»¶ï¼ŒåŒæ—¶å¿½ç•¥éšè—æ–‡ä»¶ã€‚å®ƒè¿˜å®ç°äº†åŸºäºå…³é”®è¯çš„å…¨æ–‡æœç´¢åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ ‡é¢˜åŠ æƒã€è¯é¢‘åŠ æƒã€ä¸Šä¸‹æ–‡æå–å’Œç»“æœæ’åºï¼Œæœ€ç»ˆè¿”å›å¸¦é«˜äº®å’Œç›¸å…³æ€§è¯„åˆ†çš„æœç´¢ç»“æœã€‚æ­¤å¤–ï¼Œå®ƒæä¾› Markdown åˆ° HTML çš„æ¸²æŸ“èƒ½åŠ›ï¼Œç”¨äºå‰ç«¯å±•ç¤ºã€‚",
    "interfaces": [
      {
        "description": "è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿä¸­å•ä¸ªèŠ‚ç‚¹ï¼ˆæ–‡ä»¶æˆ–ç›®å½•ï¼‰çš„æ•°æ®ç»“æ„ï¼Œæ”¯æŒåºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œç”¨äºè·¨æœåŠ¡ä¼ è¾“æˆ–æŒä¹…åŒ–ã€‚",
        "interface_type": "struct",
        "name": "FileNode",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "is_file",
            "param_type": "bool"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "children",
            "param_type": "Vec<FileNode>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "size",
            "param_type": "Option<u64>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "modified",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "è¡¨ç¤ºä¸€æ¬¡æœç´¢æŸ¥è¯¢è¿”å›çš„å•ä¸ªç»“æœï¼ŒåŒ…å«æ–‡ä»¶è·¯å¾„ã€åŒ¹é…å†…å®¹ã€æ ‡é¢˜å’Œç›¸å…³æ€§è¯„åˆ†ã€‚",
        "interface_type": "struct",
        "name": "SearchResult",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "file_path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "file_name",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "title",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "matches",
            "param_type": "Vec<SearchMatch>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "relevance_score",
            "param_type": "f32"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "è¡¨ç¤ºæœç´¢åŒ¹é…çš„å…·ä½“è¡Œå†…å®¹ï¼ŒåŒ…å«é«˜äº®æ–‡æœ¬å’Œä¸Šä¸‹æ–‡è¡Œï¼Œç”¨äºå‰ç«¯å±•ç¤ºåŒ¹é…ä¸Šä¸‹æ–‡ã€‚",
        "interface_type": "struct",
        "name": "SearchMatch",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "line_number",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "highlighted_content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "context_before",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "context_after",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "æ–‡æ¡£æ ‘çš„ä¸»ç»“æ„ï¼Œå°è£…äº†æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„æ ‘å½¢ç»“æ„ã€è·¯å¾„æ˜ å°„ã€æœç´¢ç´¢å¼•å’Œç»Ÿè®¡ä¿¡æ¯ï¼Œæ˜¯ç»„ä»¶å¯¹å¤–æš´éœ²çš„æ ¸å¿ƒæ¥å£ã€‚",
        "interface_type": "struct",
        "name": "DocumentTree",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "root",
            "param_type": "FileNode"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "file_map",
            "param_type": "HashMap<String, PathBuf>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "stats",
            "param_type": "TreeStats"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "search_index",
            "param_type": "HashMap<String, Vec<String>>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "å­˜å‚¨æ–‡æ¡£æ ‘çš„ç»Ÿè®¡ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ–‡ä»¶æ•°ã€ç›®å½•æ•°å’Œæ€»å¤§å°ã€‚",
        "interface_type": "struct",
        "name": "TreeStats",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "total_files",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_dirs",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_size",
            "param_type": "u64"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      }
    ],
    "responsibilities": [
      "é€’å½’æ‰«æç›®å½•å¹¶æ„å»ºæ–‡ä»¶ç³»ç»Ÿæ ‘å½¢ç»“æ„ï¼ˆDocumentTreeï¼‰",
      "ç»´æŠ¤æ–‡ä»¶è·¯å¾„åˆ°å®é™…æ–‡ä»¶çš„æ˜ å°„ï¼ˆfile_mapï¼‰ä»¥æ”¯æŒå¿«é€Ÿå†…å®¹è¯»å–",
      "ä¸º Markdown æ–‡ä»¶æ„å»ºå…¨æ–‡æœç´¢ç´¢å¼•ï¼ˆsearch_indexï¼‰",
      "å®ç°åŸºäºå…³é”®è¯çš„é«˜çº§å…¨æ–‡æœç´¢åŠŸèƒ½ï¼ŒåŒ…å«ç›¸å…³æ€§è¯„åˆ†å’Œé«˜äº®æ˜¾ç¤º",
      "æä¾› Markdown å†…å®¹æ¸²æŸ“ä¸º HTML çš„èƒ½åŠ›"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "model",
      "description": null,
      "file_path": "src/error.rs",
      "functions": [
        "From<LithoBookError> for axum::http::StatusCode"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "LithoBookError"
      ],
      "name": "error.rs",
      "source_summary": "use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum LithoBookError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"JSON serialization error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"File not found: {path}\")]\n    FileNotFound { path: String },\n\n    #[error(\"Invalid file path: {path}\")]\n    InvalidPath { path: String },\n\n    #[error(\"Directory scan error: {0}\")]\n    DirectoryScan(String),\n\n    #[error(\"Server error: {0}\")]\n    Server(String),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n}\n\nimpl From<LithoBookError> for axum::http::StatusCode {\n    fn from(err: LithoBookError) -> Self {\n        match err {\n            LithoBookError::FileNotFound { .. } => axum::http::StatusCode::NOT_FOUND,\n            LithoBookError::InvalidPath { .. } => axum::http::StatusCode::BAD_REQUEST,\n            LithoBookError::Json(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR,\n            LithoBookError::Io(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR,\n            LithoBookError::DirectoryScan(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR,\n            LithoBookError::Server(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR,\n            LithoBookError::Config(_) => axum::http::StatusCode::BAD_REQUEST,\n        }\n    }\n}\n"
    },
    "complexity_metrics": {
      "cohesion_score": 0.95,
      "coupling_factor": 0.7,
      "cyclomatic_complexity": 3.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 39,
      "number_of_classes": 1,
      "number_of_functions": 1
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "thiserror",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde_json",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "std",
        "is_external": false,
        "line_number": null,
        "name": "std::io",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "axum::http::StatusCode",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "è¯¥ç»„ä»¶å®šä¹‰äº†ä¸€ä¸ªåä¸º LithoBookError çš„æšä¸¾ç±»å‹ï¼Œç”¨äºç»Ÿä¸€ç®¡ç† LithoBook åº”ç”¨ä¸­çš„æ‰€æœ‰è‡ªå®šä¹‰é”™è¯¯ç±»å‹ã€‚å®ƒæ•´åˆäº†æ ‡å‡†åº“çš„ IO é”™è¯¯ã€serde_json çš„åºåˆ—åŒ–é”™è¯¯ï¼Œå¹¶å®šä¹‰äº†åº”ç”¨å±‚ç‰¹å®šçš„é”™è¯¯ï¼Œå¦‚æ–‡ä»¶æœªæ‰¾åˆ°ã€è·¯å¾„æ— æ•ˆã€ç›®å½•æ‰«æå¤±è´¥ã€æœåŠ¡å™¨é”™è¯¯å’Œé…ç½®é”™è¯¯ã€‚åŒæ—¶ï¼Œé€šè¿‡å®ç° From<LithoBookError> for axum::http::StatusCodeï¼Œè¯¥ç»„ä»¶å°†åº”ç”¨å±‚é”™è¯¯è‡ªåŠ¨æ˜ å°„ä¸º HTTP çŠ¶æ€ç ï¼Œä¸º Axum HTTP æ¡†æ¶æä¾›æ ‡å‡†åŒ–çš„é”™è¯¯å“åº”æœºåˆ¶ï¼Œæ˜¯ç³»ç»Ÿé”™è¯¯å¤„ç†çš„æ ¸å¿ƒæ¢çº½ã€‚",
    "interfaces": [
      {
        "description": null,
        "interface_type": "enum",
        "name": "LithoBookError",
        "parameters": [
          {
            "description": "å°è£…åº•å±‚ I/O æ“ä½œå¤±è´¥",
            "is_optional": false,
            "name": "Io",
            "param_type": "std::io::Error"
          },
          {
            "description": "å°è£… JSON åºåˆ—åŒ–/ååºåˆ—åŒ–å¤±è´¥",
            "is_optional": false,
            "name": "Json",
            "param_type": "serde_json::Error"
          },
          {
            "description": "æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæºå¸¦è·¯å¾„ä¿¡æ¯",
            "is_optional": false,
            "name": "FileNotFound",
            "param_type": "FileNotFound"
          },
          {
            "description": "è·¯å¾„æ ¼å¼éæ³•ï¼Œæºå¸¦è·¯å¾„ä¿¡æ¯",
            "is_optional": false,
            "name": "InvalidPath",
            "param_type": "InvalidPath"
          },
          {
            "description": "ç›®å½•æ‰«æè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯",
            "is_optional": false,
            "name": "DirectoryScan",
            "param_type": "String"
          },
          {
            "description": "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œæºå¸¦æè¿°ä¿¡æ¯",
            "is_optional": false,
            "name": "Server",
            "param_type": "String"
          },
          {
            "description": "é…ç½®åŠ è½½æˆ–è§£æå¤±è´¥",
            "is_optional": false,
            "name": "Config",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      }
    ],
    "responsibilities": [
      "å®šä¹‰åº”ç”¨å±‚ç»Ÿä¸€é”™è¯¯æšä¸¾ç±»å‹ï¼Œé›†ä¸­ç®¡ç†æ‰€æœ‰é”™è¯¯åœºæ™¯",
      "å°è£…ç¬¬ä¸‰æ–¹åº“é”™è¯¯ï¼ˆstd::io::Error, serde_json::Errorï¼‰ä¸ºåº”ç”¨å†…ä¸€è‡´é”™è¯¯æ¨¡å‹",
      "å®ç° HTTP çŠ¶æ€ç è½¬æ¢é€»è¾‘ï¼Œä¸º Axum æ¡†æ¶æä¾›é”™è¯¯å“åº”æ˜ å°„",
      "ä¸ºä¸Šå±‚æœåŠ¡æä¾›æ¸…æ™°ã€å¯è¯»ã€ç»“æ„åŒ–çš„é”™è¯¯ä¿¡æ¯ï¼Œä¾¿äºè°ƒè¯•ä¸å‰ç«¯å±•ç¤º",
      "ä½œä¸ºé”™è¯¯ä¼ æ’­çš„æ ‡å‡†åŒ–æ¥å£ï¼Œç¡®ä¿é”™è¯¯åœ¨ç³»ç»Ÿå„å±‚é—´ä¸€è‡´ä¼ é€’"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "api",
      "description": null,
      "file_path": "src/server.rs",
      "functions": [
        "create_router",
        "index_handler",
        "get_file_handler",
        "get_tree_handler",
        "search_handler",
        "stats_handler",
        "health_handler",
        "chat_stream_handler",
        "call_openai_stream_api",
        "generate_suggestions",
        "format_bytes",
        "generate_index_html"
      ],
      "importance_score": 0.8,
      "interfaces": [
        "AppState",
        "FileQuery",
        "SearchQuery",
        "FileResponse",
        "SearchResponse",
        "StatsResponse",
        "ChatRequest",
        "OpenAIMessage",
        "OpenAIRequest",
        "OpenAIStreamChoice",
        "OpenAIStreamDelta",
        "OpenAIStreamResponse",
        "StreamEvent"
      ],
      "name": "server.rs",
      "source_summary": "use axum::{\n    Router,\n    extract::{Query, State},\n    http::StatusCode,\n    response::{Html, Json, Sse, sse::Event},\n    routing::{get, post},\n};\nuse futures::stream::Stream;\nuse serde::{Deserialize, Serialize};\nuse std::convert::Infallible;\nuse std::time::Duration;\nuse tower_http::cors::CorsLayer;\nuse tracing::{debug, error, info};\n\nuse crate::filesystem::{DocumentTree, SearchResult};\n\n#[derive(Clone)]\npub struct AppState {\n    pub doc_tree: DocumentTree,\n    pub docs_path: String,\n}\n\n#[derive(Deserialize)]\npub struct FileQuery {\n    file: Option<String>,\n}\n\n#[derive(Deserialize)]\npub struct SearchQuery {\n    q: Option<String>,\n}\n\n#[derive(Serialize)]\npub struct FileResponse {\n    pub content: String,\n    pub html: String,\n    pub path: String,\n    pub size: Option<u64>,\n    pub modified: Option<String>,\n}\n\n#[derive(Serialize)]\npub struct SearchResponse {\n    pub results: Vec<SearchResult>,\n    pub total: usize,\n    pub query: String,\n}\n\n#[derive(Serialize)]\npub struct StatsResponse {\n    pub total_files: usize,\n    pub total_dirs: usize,\n    pub total_size: u64,\n    pub formatted_size: String,\n}\n\n// AIåŠ©æ‰‹ç›¸å…³çš„æ•°æ®ç»“æ„\n#[derive(Deserialize)]\npub struct ChatRequest {\n    pub message: String,\n    pub context: Option<String>,             // å½“å‰æ–‡æ¡£å†…å®¹ä½œä¸ºä¸Šä¸‹æ–‡\n    pub history: Option<Vec<OpenAIMessage>>, // å†å²ä¼šè¯æ¶ˆæ¯\n}\n\n#[derive(Serialize, Deserialize)]\npub struct OpenAIMessage {\n    pub role: String,\n    pub content: String,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct OpenAIRequest {\n    pub model: String,\n    pub messages: Vec<OpenAIMessage>,\n    pub temperature: f32,\n    pub max_tokens: i32,\n    pub stream: bool,\n}\n// æµå¼å“åº”ç›¸å…³çš„æ•°æ®ç»“æ„\n#[derive(Deserialize)]\npub struct OpenAIStreamChoice {\n    pub delta: OpenAIStreamDelta,\n    pub finish_reason: Option<String>,\n}\n\n#[derive(Deserialize)]\npub struct OpenAIStreamDelta {\n    pub content: Option<String>,\n}\n\n#[derive(Deserialize)]\npub struct OpenAIStreamResponse {\n    pub choices: Vec<OpenAIStreamChoice>,\n}\n\n#[derive(Serialize)]\npub struct StreamEvent {\n    pub event_type: String,\n    pub content: Option<String>,\n    pub suggestions: Option<Vec<String>>,\n    pub finished: bool,\n}\n\n/// Create the main application router\npub fn create_router(doc_tree: DocumentTree, docs_path: String) -> Router {\n    let state = AppState {\n        doc_tree,\n        docs_path,\n    };\n\n    Router::new()\n        .route(\"/\", get(index_handler))\n        .route(\"/api/file\", get(get_file_handler))\n        .route(\"/api/tree\", get(get_tree_handler))\n        .route(\"/api/search\", get(search_handler))\n        .route(\"/api/stats\", get(stats_handler))\n        .route(\"/api/chat\", post(chat_stream_handler))\n        .route(\"/health\", get(health_handler))\n        .layer(CorsLayer::permissive())\n        .with_state(state)\n}\n\n/// Serve the main index page\nasync fn index_handler(State(state): State<AppState>) -> Result<Html<String>, StatusCode> {\n    debug!(\"Serving index page\");\n\n    let tree_json = serde_json::to_string(&state.doc_tree.root).map_err(|e| {\n        error!(\"Failed to serialize document tree: {}\", e);\n        StatusCode::INTERNAL_SERVER_ERROR\n    })?;\n\n    let html = generate_index_html(&tree_json, &state.docs_path);\n    Ok(Html(html))\n}\n\n/// Get file content and render as HTML\nasync fn get_file_handler(\n    Query(params): Query<FileQuery>,\n    State(state): State<AppState>,\n) -> Result<Json<FileResponse>, StatusCode> {\n    let file_path = params.file.ok_or_else(|| {\n        debug!(\"Missing file parameter in request\");\n        StatusCode::BAD_REQUEST\n    })?;\n\n    debug!(\"Requesting file: {}\", file_path);\n\n    let content = state.doc_tree.get_file_content(&file_path).map_err(|e| {\n        error!(\"Failed to read file {}: {}\", file_path, e);\n        StatusCode::NOT_FOUND\n    })?;\n\n    let html = state.doc_tree.render_markdown(&content);\n\n    // Get file metadata if available\n    let file_info = state\n        .doc_tree\n        .file_map\n        .get(&file_path)\n        .and_then(|path| std::fs::metadata(path).ok())\n        .map(|metadata| {\n            let size = metadata.len();\n            let modified = metadata.modified().ok().and_then(|time| {\n                time.duration_since(std::time::UNIX_EPOCH)\n                    .ok()\n                    .map(|d| {\n                        let datetime = chrono::DateTime::from_timestamp(d.as_secs() as i64, 0)?;\n                        Some(datetime.format(\"%Y-%m-%d %H:%M:%S\").to_string())\n                    })\n                    .flatten()\n            });\n            (size, modified)\n        });\n\n    let response = FileResponse {\n        content,\n        html,\n        path: file_path,\n        size: file_info.as_ref().map(|(size, _)| *size),\n        modified: file_info.and_then(|(_, modified)| modified),\n    };\n\n    info!(\"Successfully served file: {}\", response.path);\n    Ok(Json(response))\n}\n\n/// Get the document tree structure\nasync fn get_tree_handler(State(state): State<AppState>) -> Json<serde_json::Value> {\n    debug!(\"Serving document tree\");\n    Json(serde_json::to_value(&state.doc_tree.root).unwrap_or_default())\n}\n\n/// Search for content with full-text search\nasync fn search_handler(\n    Query(params): Query<SearchQuery>,\n    State(state): State<AppState>,\n) -> Result<Json<SearchResponse>, StatusCode> {\n    let query = params.q.unwrap_or_default();\n\n    if query.trim().is_empty() {\n        return Ok(Json(SearchResponse {\n            results: vec![],\n            total: 0,\n            query: query.clone(),\n        }));\n    }\n\n    debug!(\"Searching for: {}\", query);\n\n    let results = state.doc_tree.search_content(&query);\n    let total = results.len();\n\n    debug!(\"Found {} results matching query: {}\", total, query);\n\n    Ok(Json(SearchResponse {\n        results,\n        total,\n        query,\n    }))\n}\n\n/// Get statistics about the document tree\nasync fn stats_handler(State(state): State<AppState>) -> Json<StatsResponse> {\n    let stats = state.doc_tree.get_stats();\n\n    let formatted_size = format_bytes(stats.total_size);\n\n    Json(StatsResponse {\n        total_files: stats.total_files,\n        total_dirs: stats.total_dirs,\n        total_size: stats.total_size,\n        formatted_size,\n    })\n}\n\n/// Health check endpoint\nasync fn health_handler() -> Json<serde_json::Value> {\n    Json(serde_json::json!({\n        \"status\": \"healthy\",\n        \"timestamp\": chrono::Utc::now().to_rfc3339(),\n        \"version\": env!(\"CARGO_PKG_VERSION\")\n    }))\n}\n\n/// AIåŠ©æ‰‹æµå¼èŠå¤©å¤„ç†å‡½æ•°\nasync fn chat_stream_handler(\n    State(state): State<AppState>,\n    Json(request): Json<ChatRequest>,\n) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {\n    debug!(\"AIåŠ©æ‰‹æ”¶åˆ°æ¶ˆæ¯: {}\", request.message);\n\n    let stream = async_stream::stream! {\n        match call_openai_stream_api(\n            &request.message,\n            request.context.as_deref(),\n            request.history,\n            &state.docs_path,\n        ).await {\n            Ok(mut response_stream) => {\n                let mut full_response = String::new();\n\n                // å‘é€å¼€å§‹äº‹ä»¶\n                yield Ok(Event::default()\n                    .event(\"start\")\n                    .data(serde_json::to_string(&StreamEvent {\n                        event_type: \"start\".to_string(),\n                        content: None,\n                        suggestions: None,\n                        finished: false,\n                    }).unwrap_or_default()));\n\n                // å¤„ç†æµå¼å“åº”\n                while let Some(chunk) = response_stream.recv().await {\n                    match chunk {\n                        Ok(content) => {\n                            full_response.push_str(&content);\n\n                            // å‘é€å†…å®¹å—\n                            yield Ok(Event::default()\n                                .event(\"content\")\n                                .data(serde_json::to_string(&StreamEvent {\n                                    event_type: \"content\".to_string(),\n                                    content: Some(content),\n                                    suggestions: None,\n                                    finished: false,\n                                }).unwrap_or_default()));\n                        }\n                        Err(e) => {\n                            error!(\"æµå¼å“åº”é”™è¯¯: {}\", e);\n                            yield Ok(Event::default()\n                                .event(\"error\")\n                                .data(serde_json::to_string(&StreamEvent {\n                                    event_type: \"error\".to_string(),\n                                    content: Some(\"æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›ç­”æ‚¨çš„é—®é¢˜ã€‚è¯·ç¨åå†è¯•ã€‚\".to_string()),\n                                    suggestions: None,\n                                    finished: true,\n                                }).unwrap_or_default()));\n                            return;\n                        }\n                    }\n                }\n\n                // ç”Ÿæˆæ¨èé—®é¢˜\n                let suggestions = generate_suggestions(&full_response, request.context.as_deref());\n\n                // å‘é€å®Œæˆäº‹ä»¶\n                yield Ok(Event::default()\n                    .event(\"finish\")\n                    .data(serde_json::to_string(&StreamEvent {\n                        event_type: \"finish\".to_string(),\n                        content: None,\n                        suggestions: Some(suggestions),\n                        finished: true,\n                    }).unwrap_or_default()));\n            }\n            Err(e) => {\n                error!(\"è°ƒç”¨AI APIå¤±è´¥: {}\", e);\n                yield Ok(Event::default()\n                    .event(\"error\")\n                    .data(serde_json::to_string(&StreamEvent {\n                        event_type: \"error\".to_string(),\n                        content: Some(\"æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›ç­”æ‚¨çš„é—®é¢˜ã€‚è¯·ç¨åå†è¯•ã€‚\".to_string()),\n                        suggestions: None,\n                        finished: true,\n                    }).unwrap_or_default()));\n            }\n        }\n    };\n\n    Sse::new(stream).keep_alive(\n        axum::response::sse::KeepAlive::new()\n            .interval(Duration::from_secs(1))\n            .text(\"keep-alive-text\"),\n    )\n}\n\n/// è°ƒç”¨OpenAIå…¼å®¹çš„æµå¼API\nasync fn call_openai_stream_api(\n    message: &str,\n    context: Option<&str>,\n    history: Option<Vec<OpenAIMessage>>,\n    docs_path: &str,\n) -> Result<\n    tokio::sync::mpsc::Receiver<Result<String, Box<dyn std::error::Error + Send + Sync>>>,\n    Box<dyn std::error::Error + Send + Sync>,\n> {\n    let client = reqwest::Client::new();\n\n    // æ„å»ºç³»ç»Ÿæç¤ºè¯\n    let mut system_prompt = \"ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ–‡æ¡£åŠ©æ‰‹ï¼Œä¸“é—¨å¸®åŠ©ç”¨æˆ·ç†è§£å’Œåˆ†ææŠ€æœ¯æ–‡æ¡£ã€‚è¯·ç”¨ä¸­æ–‡å›ç­”é—®é¢˜ï¼Œå›ç­”è¦å‡†ç¡®ã€ç®€æ´ã€æœ‰å¸®åŠ©ã€‚\".to_string();\n\n    // æ·»åŠ æ¶æ„æ¦‚è§ˆæ–‡æ¡£ä½œä¸ºèƒŒæ™¯ææ–™\n    let architecture_path = std::path::Path::new(docs_path).join(\"2ã€æ¶æ„æ¦‚è§ˆ.md\");\n    if let Ok(architecture_content) = std::fs::read_to_string(&architecture_path) {\n        system_prompt.push_str(&format!(\"\\n\\nç”¨æˆ·æ‰€å…³æ³¨é¡¹ç›®çš„æ¶æ„æ¦‚è§ˆï¼š\\n{}\", architecture_content));\n    }\n\n    if let Some(ctx) = context {\n        system_prompt.push_str(&format!(\"\\n\\nç”¨æˆ·å½“å‰æ­£åœ¨æŸ¥çœ‹çš„æ–‡æ¡£å†…å®¹ï¼š\\n{}\", ctx));\n    }\n\n    // æ„å»ºæ¶ˆæ¯åˆ—è¡¨\n    let mut messages = vec![OpenAIMessage {\n        role: \"system\".to_string(),\n        content: system_prompt,\n    }];\n\n    // æ·»åŠ å†å²æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰\n    if let Some(hist) = history {\n        // é™åˆ¶å†å²æ¶ˆæ¯æ•°é‡ï¼Œé¿å…è¯·æ±‚è¿‡å¤§\n        let max_history = 10; // æœ€å¤šä¿ç•™10è½®å¯¹è¯\n        let start_index = if hist.len() > max_history {\n            hist.len() - max_history\n        } else {\n            0\n        };\n        messages.extend(hist.into_iter().skip(start_index));\n    }\n\n    // æ·»åŠ å½“å‰ç”¨æˆ·æ¶ˆæ¯\n    messages.push(OpenAIMessage {\n        role: \"user\".to_string(),\n        content: message.to_string(),\n    });\n\n    let request_body = OpenAIRequest {\n        model: \"GLM-4.5-Flash\".to_string(),\n        messages,\n        temperature: 0.7,\n        max_tokens: 16384,\n        stream: true, // å¯ç”¨æµå¼å“åº”\n    };\n\n    let response = client\n        .post(\"https://open.bigmodel.cn/api/paas/v4/chat/completions\")\n        .header(\n            \"Authorization\",\n            \"Bearer your-llm-key\",\n        )\n        .header(\"Content-Type\", \"application/json\")\n        .json(&request_body)\n        .send()\n        .await?;\n\n    if !response.status().is_success() {\n        let status = response.status();\n        let text = response.text().await.unwrap_or_default();\n        return Err(format!(\"APIè¯·æ±‚å¤±è´¥: {} - {}\", status, text).into());\n    }\n\n    // åˆ›å»ºé€šé“æ¥ä¼ é€’æµå¼æ•°æ®\n    let (tx, rx) = tokio::sync::mpsc::channel(100);\n\n    // åœ¨åå°ä»»åŠ¡ä¸­å¤„ç†æµå¼å“åº”\n    tokio::spawn(async move {\n        use futures::StreamExt;\n\n        let mut stream = response.bytes_stream();\n        let mut buffer = String::new();\n\n        while let Some(chunk_result) = stream.next().await {\n            match chunk_result {\n                Ok(chunk) => {\n                    let chunk_str = String::from_utf8_lossy(&chunk);\n                    buffer.push_str(&chunk_str);\n\n                    // å¤„ç†SSEæ ¼å¼çš„æ•°æ®\n                    let lines: Vec<&str> = buffer.lines().collect();\n                    let mut processed_lines = 0;\n\n                    for line in &lines {\n                        if line.starts_with(\"data: \") {\n                            let data = &line[6..]; // ç§»é™¤ \"data: \" å‰ç¼€\n\n                            if data == \"[DONE]\" {\n                                // æµç»“æŸ\n                                return;\n                            }\n\n                            // å°è¯•è§£æJSON\n                            if let Ok(stream_response) =\n                                serde_json::from_str::<OpenAIStreamResponse>(data)\n                            {\n                                if let Some(choice) = stream_response.choices.first() {\n                                    if let Some(content) = &choice.delta.content {\n                                        if !content.is_empty() {\n                                            if tx.send(Ok(content.clone())).await.is_err() {\n                                                return; // æ¥æ”¶ç«¯å·²å…³é—­\n                                            }\n                                        }\n                                    }\n\n                                    // æ£€æŸ¥æ˜¯å¦å®Œæˆ\n                                    if choice.finish_reason.is_some() {\n                                        return;\n                                    }\n                                }\n                            }\n                            processed_lines += 1;\n                        } else if line.is_empty() {\n                            processed_lines += 1;\n                        } else {\n                            processed_lines += 1;\n                        }\n                    }\n\n                    // ä¿ç•™æœªå¤„ç†çš„éƒ¨åˆ†\n                    if processed_lines < lines.len() {\n                        buffer = lines[processed_lines..].join(\"\\n\");\n                    } else {\n                        buffer.clear();\n                    }\n                }\n                Err(e) => {\n                    let _ = tx.send(Err(format!(\"æµå¼å“åº”é”™è¯¯: {}\", e).into())).await;\n                    return;\n                }\n            }\n        }\n    });\n\n    Ok(rx)\n}\n\n/// ç”Ÿæˆæ¨èçš„è¿½é—®é—®é¢˜\nfn generate_suggestions(ai_response: &str, _context: Option<&str>) -> Vec<String> {\n    let mut suggestions = Vec::new();\n\n    // åŸºäºAIå›ç­”å†…å®¹ç”Ÿæˆç›¸å…³é—®é¢˜\n    if ai_response.contains(\"æ¶æ„\") || ai_response.contains(\"è®¾è®¡\") {\n        suggestions.push(\"è¿™ä¸ªæ¶æ„çš„ä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ\".to_string());\n        suggestions.push(\"æœ‰å“ªäº›æ›¿ä»£çš„è®¾è®¡æ–¹æ¡ˆï¼Ÿ\".to_string());\n    }\n\n    if ai_response.contains(\"æ€§èƒ½\") || ai_response.contains(\"è€—æ—¶\") {\n        suggestions.push(\"é¡¹ç›®ä½¿ç”¨äº†å“ªäº›æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Ÿ\".to_string());\n        suggestions.push(\"å¦‚ä½•ä¼˜åŒ–é¡¹ç›®ä¸­çš„æ€§èƒ½çƒ­ç‚¹ï¼Ÿ\".to_string());\n    }\n\n    if ai_response.contains(\"é…ç½®\") || ai_response.contains(\"å‚æ•°\") {\n        suggestions.push(\"è¿™äº›é…ç½®çš„é»˜è®¤å€¼æ˜¯ä»€ä¹ˆï¼Ÿ\".to_string());\n        suggestions.push(\"å¦‚ä½•è°ƒä¼˜è¿™äº›å‚æ•°ï¼Ÿ\".to_string());\n    }\n\n    // å¦‚æœæ²¡æœ‰ç‰¹å®šçš„å»ºè®®ï¼Œæä¾›é€šç”¨çš„\n    if suggestions.is_empty() {\n        suggestions.push(\"èƒ½è¯¦ç»†è§£é‡Šä¸€ä¸‹å—ï¼Ÿ\".to_string());\n        suggestions.push(\"æœ‰ç›¸å…³çš„ç¤ºä¾‹å—ï¼Ÿ\".to_string());\n        suggestions.push(\"è¿™ä¸ªæœ‰ä»€ä¹ˆæœ€ä½³å®è·µï¼Ÿ\".to_string());\n    }\n\n    // é™åˆ¶å»ºè®®æ•°é‡\n    suggestions.truncate(3);\n    suggestions\n}\n\n/// Format bytes into human-readable format\nfn format_bytes(bytes: u64) -> String {\n    const UNITS: &[&str] = &[\"B\", \"KB\", \"MB\", \"GB\", \"TB\"];\n\n    if bytes == 0 {\n        return \"0 B\".to_string();\n    }\n\n    let mut size = bytes as f64;\n    let mut unit_index = 0;\n\n    while size >= 1024.0 && unit_index < UNITS.len() - 1 {\n        size /= 1024.0;\n        unit_index += 1;\n    }\n\n    if unit_index == 0 {\n        format!(\"{} {}\", bytes, UNITS[unit_index])\n    } else {\n        format!(\"{:.1} {}\", size, UNITS[unit_index])\n    }\n}\n\n/// Generate the main HTML page\nfn generate_index_html(tree_json: &str, docs_path: &str) -> String {\n    // Read the template file\n    let template_content = include_str!(\"../templates/index.html.tpl\");\n\n    // Replace the placeholders with actual data\n    template_content\n        .replace(\"{{ tree_json|safe }}\", tree_json)\n        .replace(\"{{ docs_path }}\", docs_path)\n}\n"
    },
    "complexity_metrics": {
      "cohesion_score": 0.85,
      "coupling_factor": 0.65,
      "cyclomatic_complexity": 32.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 549,
      "number_of_classes": 13,
      "number_of_functions": 12
    },
    "dependencies": [
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "axum",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "futures",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "serde",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "tower_http",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "tracing",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "module",
        "is_external": false,
        "line_number": null,
        "name": "crate::filesystem",
        "path": "src/filesystem/mod.rs",
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "reqwest",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "crate",
        "is_external": true,
        "line_number": null,
        "name": "async_stream",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "è¯¥ç»„ä»¶æ˜¯åŸºäºAxumæ¡†æ¶æ„å»ºçš„HTTP APIæœåŠ¡ç«¯æ ¸å¿ƒï¼Œæä¾›æ–‡æ¡£æµè§ˆã€å…¨æ–‡æœç´¢ã€ç³»ç»Ÿç»Ÿè®¡å’ŒAIåŠ©æ‰‹æµå¼å¯¹è¯å››å¤§æ ¸å¿ƒåŠŸèƒ½ã€‚å®ƒé€šè¿‡å®šä¹‰ä¸€ç³»åˆ—è·¯ç”±å¤„ç†å™¨å¤„ç†å‰ç«¯è¯·æ±‚ï¼ŒåŒ…æ‹¬è·å–æ–‡ä»¶å†…å®¹ï¼ˆMarkdownæ¸²æŸ“ä¸ºHTMLï¼‰ã€è·å–ç›®å½•æ ‘ç»“æ„ã€æ‰§è¡Œå…¨æ–‡æœç´¢ã€è¿”å›ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯ã€å¥åº·æ£€æŸ¥ï¼Œä»¥åŠæœ€é‡è¦çš„AIèŠå¤©æµå¼å“åº”ã€‚AIèŠå¤©åŠŸèƒ½é€šè¿‡è°ƒç”¨æ™ºè°±AIçš„OpenAIå…¼å®¹APIï¼Œæ„å»ºåŒ…å«ç³»ç»Ÿæç¤ºè¯ã€ä¸Šä¸‹æ–‡å’Œå†å²ä¼šè¯çš„è¯·æ±‚ï¼Œæ¥æ”¶æµå¼å“åº”å¹¶è½¬æ¢ä¸ºSSEäº‹ä»¶æµè¿”å›ç»™å‰ç«¯ã€‚ç»„ä»¶è¿˜åŒ…å«è¾…åŠ©å‡½æ•°ç”¨äºç”Ÿæˆæ¨èé—®é¢˜ã€æ ¼å¼åŒ–å­—èŠ‚æ•°å’Œç”ŸæˆHTMLé¦–é¡µæ¨¡æ¿ã€‚æ•´ä¸ªæœåŠ¡é€šè¿‡AppStateå…±äº«æ–‡æ¡£æ ‘çŠ¶æ€ï¼Œæ”¯æŒé«˜å¹¶å‘è¯·æ±‚å¤„ç†ã€‚",
    "interfaces": [
      {
        "description": "åº”ç”¨çŠ¶æ€å®¹å™¨ï¼Œç”¨äºåœ¨å¤šä¸ªè¯·æ±‚å¤„ç†å™¨é—´å…±äº«æ–‡æ¡£æ ‘å’Œæ–‡æ¡£æ ¹è·¯å¾„",
        "interface_type": "struct",
        "name": "AppState",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "doc_tree",
            "param_type": "DocumentTree"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "docs_path",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "è·å–æ–‡ä»¶å†…å®¹è¯·æ±‚çš„æŸ¥è¯¢å‚æ•°ç»“æ„",
        "interface_type": "struct",
        "name": "FileQuery",
        "parameters": [
          {
            "description": null,
            "is_optional": true,
            "name": "file",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "å…¨æ–‡æœç´¢è¯·æ±‚çš„æŸ¥è¯¢å‚æ•°ç»“æ„",
        "interface_type": "struct",
        "name": "SearchQuery",
        "parameters": [
          {
            "description": null,
            "is_optional": true,
            "name": "q",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "æ–‡ä»¶å†…å®¹å“åº”çš„æ•°æ®ç»“æ„ï¼ŒåŒ…å«åŸå§‹å†…å®¹ã€æ¸²æŸ“åçš„HTMLå’Œå…ƒæ•°æ®",
        "interface_type": "struct",
        "name": "FileResponse",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "html",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "path",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "size",
            "param_type": "Option<u64>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "modified",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "æœç´¢ç»“æœå“åº”çš„æ•°æ®ç»“æ„",
        "interface_type": "struct",
        "name": "SearchResponse",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "results",
            "param_type": "Vec<SearchResult>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "query",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯å“åº”çš„æ•°æ®ç»“æ„",
        "interface_type": "struct",
        "name": "StatsResponse",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "total_files",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_dirs",
            "param_type": "usize"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "total_size",
            "param_type": "u64"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "formatted_size",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "AIèŠå¤©è¯·æ±‚çš„è¾“å…¥æ•°æ®ç»“æ„",
        "interface_type": "struct",
        "name": "ChatRequest",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "message",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "context",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "history",
            "param_type": "Option<Vec<OpenAIMessage>>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "ä¸OpenAI APIé€šä¿¡çš„æ¶ˆæ¯ç»“æ„ï¼Œè¡¨ç¤ºå¯¹è¯ä¸­çš„å•æ¡æ¶ˆæ¯",
        "interface_type": "struct",
        "name": "OpenAIMessage",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "role",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "content",
            "param_type": "String"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "å‘OpenAIå…¼å®¹APIå‘é€è¯·æ±‚çš„å®Œæ•´å‚æ•°ç»“æ„",
        "interface_type": "struct",
        "name": "OpenAIRequest",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "model",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "messages",
            "param_type": "Vec<OpenAIMessage>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "temperature",
            "param_type": "f32"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "max_tokens",
            "param_type": "i32"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "stream",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "è§£æOpenAIæµå¼å“åº”ä¸­å•ä¸ªé€‰æ‹©ï¼ˆchoiceï¼‰çš„ç»“æ„",
        "interface_type": "struct",
        "name": "OpenAIStreamChoice",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "delta",
            "param_type": "OpenAIStreamDelta"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "finish_reason",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "è¡¨ç¤ºæµå¼å“åº”ä¸­å¢é‡å†…å®¹çš„ç»“æ„",
        "interface_type": "struct",
        "name": "OpenAIStreamDelta",
        "parameters": [
          {
            "description": null,
            "is_optional": true,
            "name": "content",
            "param_type": "Option<String>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "OpenAIæµå¼å“åº”çš„é¡¶å±‚ç»“æ„",
        "interface_type": "struct",
        "name": "OpenAIStreamResponse",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "choices",
            "param_type": "Vec<OpenAIStreamChoice>"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      },
      {
        "description": "å‰ç«¯SSEäº‹ä»¶ç›‘å¬å™¨æ¥æ”¶çš„æ ‡å‡†åŒ–äº‹ä»¶ç»“æ„",
        "interface_type": "struct",
        "name": "StreamEvent",
        "parameters": [
          {
            "description": null,
            "is_optional": false,
            "name": "event_type",
            "param_type": "String"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "content",
            "param_type": "Option<String>"
          },
          {
            "description": null,
            "is_optional": true,
            "name": "suggestions",
            "param_type": "Option<Vec<String>>"
          },
          {
            "description": null,
            "is_optional": false,
            "name": "finished",
            "param_type": "bool"
          }
        ],
        "return_type": null,
        "visibility": "pub"
      }
    ],
    "responsibilities": [
      "æš´éœ²RESTful APIæ¥å£ä¾›å‰ç«¯è°ƒç”¨ï¼ŒåŒ…æ‹¬æ–‡ä»¶è¯»å–ã€æœç´¢ã€ç»Ÿè®¡å’ŒAIå¯¹è¯",
      "ç®¡ç†å¹¶å…±äº«æ–‡æ¡£æ ‘çŠ¶æ€ï¼ˆDocumentTreeï¼‰ï¼Œä½œä¸ºæ‰€æœ‰æ•°æ®æ“ä½œçš„æ ¸å¿ƒæ•°æ®æº",
      "å®ç°AIåŠ©æ‰‹æµå¼å“åº”åŠŸèƒ½ï¼Œé›†æˆå¤–éƒ¨å¤§æ¨¡å‹APIå¹¶è½¬æ¢ä¸ºSSEäº‹ä»¶æµ",
      "å¤„ç†å‰ç«¯è¯·æ±‚å‚æ•°ï¼Œè¿›è¡Œè¾“å…¥æ ¡éªŒå’Œé”™è¯¯å¤„ç†ï¼Œè¿”å›æ ‡å‡†åŒ–JSONå“åº”",
      "æ¸²æŸ“Markdownå†…å®¹ä¸ºHTMLï¼Œå¹¶ç”ŸæˆåŠ¨æ€é¦–é¡µæ¨¡æ¿"
    ]
  },
  {
    "code_dossier": {
      "code_purpose": "entry",
      "description": null,
      "file_path": "src/cli.rs",
      "functions": [
        "validate",
        "server_url",
        "bind_address",
        "is_privileged"
      ],
      "importance_score": 0.8,
      "interfaces": [],
      "name": "cli.rs",
      "source_summary": "use clap::Parser;\nuse std::path::PathBuf;\n\n#[derive(Parser, Debug)]\n#[command(name = \"litho-book\")]\n#[command(about = \"A web-based reader for litho-generated documentation\")]\n#[command(version)]\npub struct Args {\n    /// Path to the markdown documentation directory\n    #[arg(short, long, value_name = \"DIR\")]\n    pub docs_dir: PathBuf,\n    \n    /// Port to serve the web interface on\n    #[arg(short, long, default_value = \"3000\", value_name = \"PORT\")]\n    pub port: u16,\n    \n    /// Host to bind the server to\n    #[arg(long, default_value = \"127.0.0.1\", value_name = \"HOST\")]\n    pub host: String,\n    \n    /// Open browser automatically after starting the server\n    #[arg(short, long)]\n    pub open: bool,\n    \n    /// Enable verbose logging\n    #[arg(short, long)]\n    pub verbose: bool,\n}\n\nimpl Args {\n    /// Validate the command line arguments\n    pub fn validate(&self) -> anyhow::Result<()> {\n        if !self.docs_dir.exists() {\n            anyhow::bail!(\n                \"Documentation directory does not exist: {}\",\n                self.docs_dir.display()\n            );\n        }\n        \n        if !self.docs_dir.is_dir() {\n            anyhow::bail!(\n                \"Path is not a directory: {}\",\n                self.docs_dir.display()\n            );\n        }\n        \n        // Check if port is available\n        if self.port < 1024 && !is_privileged() {\n            anyhow::bail!(\n                \"Port {} requires administrator privileges. Please use a port >= 1024 or run as administrator.\",\n                self.port\n            );\n        }\n        \n        Ok(())\n    }\n    \n    /// Get the server URL\n    pub fn server_url(&self) -> String {\n        format!(\"http://{}:{}\", self.host, self.port)\n    }\n    \n    /// Get the bind address\n    pub fn bind_address(&self) -> String {\n        format!(\"{}:{}\", self.host, self.port)\n    }\n}\n\n/// Check if the current process has elevated privileges\nfn is_privileged() -> bool {\n    #[cfg(unix)]\n    {\n        unsafe { libc::geteuid() == 0 }\n    }\n    \n    #[cfg(windows)]\n    {\n        // On Windows, we'll just return true for simplicity\n        // In a real implementation, you'd check for admin privileges\n        true\n    }\n    \n    #[cfg(not(any(unix, windows)))]\n    {\n        false\n    }\n}"
    },
    "complexity_metrics": {
      "cohesion_score": 0.9,
      "coupling_factor": 0.4,
      "cyclomatic_complexity": 9.0,
      "depth_of_inheritance": 0,
      "lines_of_code": 87,
      "number_of_classes": 1,
      "number_of_functions": 4
    },
    "dependencies": [
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "clap",
        "path": null,
        "version": null
      },
      {
        "dependency_type": "library",
        "is_external": true,
        "line_number": null,
        "name": "anyhow",
        "path": null,
        "version": null
      }
    ],
    "detailed_description": "è¯¥ç»„ä»¶æ˜¯Litho-Booké¡¹ç›®çš„å‘½ä»¤è¡Œå…¥å£ï¼Œä½¿ç”¨clapåº“å®šä¹‰å‘½ä»¤è¡Œå‚æ•°è§£æç»“æ„ä½“Argsã€‚å®ƒè´Ÿè´£è§£æç”¨æˆ·è¾“å…¥çš„æ–‡æ¡£ç›®å½•è·¯å¾„ã€æœåŠ¡ç«¯å£ã€ä¸»æœºåœ°å€ã€æ˜¯å¦è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ä»¥åŠæ˜¯å¦å¯ç”¨è¯¦ç»†æ—¥å¿—ç­‰é…ç½®ã€‚é€šè¿‡å®ç°validateæ–¹æ³•å¯¹è¾“å…¥å‚æ•°è¿›è¡Œåˆæ³•æ€§æ ¡éªŒï¼Œç¡®ä¿æ–‡æ¡£ç›®å½•å­˜åœ¨ä¸”ä¸ºç›®å½•ï¼ŒåŒæ—¶æ£€æŸ¥ä½æƒé™ç«¯å£ï¼ˆ<1024ï¼‰æ˜¯å¦å…·å¤‡ç®¡ç†å‘˜æƒé™ã€‚æ­¤å¤–ï¼Œæä¾›server_urlå’Œbind_addressä¸¤ä¸ªè¾…åŠ©æ–¹æ³•ç”¨äºç”ŸæˆæœåŠ¡åœ°å€å­—ç¬¦ä¸²ã€‚ç»„ä»¶è¿˜åŒ…å«ä¸€ä¸ªå¹³å°ç›¸å…³çš„is_privilegedå‡½æ•°ï¼Œç”¨äºæ£€æµ‹å½“å‰è¿›ç¨‹æ˜¯å¦å…·æœ‰ç®¡ç†å‘˜æƒé™ï¼Œä»¥æ”¯æŒè·¨å¹³å°çš„ç«¯å£æƒé™æ£€æŸ¥ã€‚",
    "interfaces": [],
    "responsibilities": [
      "è§£æç”¨æˆ·é€šè¿‡å‘½ä»¤è¡Œä¼ å…¥çš„é…ç½®å‚æ•°",
      "éªŒè¯æ–‡æ¡£ç›®å½•è·¯å¾„çš„æœ‰æ•ˆæ€§ï¼ˆå­˜åœ¨ä¸”ä¸ºç›®å½•ï¼‰",
      "æ£€æŸ¥ä½æƒé™ç«¯å£ï¼ˆ<1024ï¼‰æ˜¯å¦å…·å¤‡ç®¡ç†å‘˜æƒé™",
      "æä¾›æœåŠ¡URLå’Œç»‘å®šåœ°å€çš„ç”Ÿæˆé€»è¾‘",
      "å°è£…è·¨å¹³å°æƒé™æ£€æŸ¥é€»è¾‘ä»¥æ”¯æŒUnixå’ŒWindowsç³»ç»Ÿ"
    ]
  }
]
```

## Memoryå­˜å‚¨ç»Ÿè®¡

**æ€»å­˜å‚¨å¤§å°**: 217372 bytes

- **studies_research**: 41482 bytes (19.1%)
- **preprocess**: 80239 bytes (36.9%)
- **documentation**: 95615 bytes (44.0%)
- **timing**: 36 bytes (0.0%)

## ç”Ÿæˆæ–‡æ¡£ç»Ÿè®¡

ç”Ÿæˆæ–‡æ¡£æ•°é‡: 7 ä¸ª

- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_æ–‡æ¡£æ•°æ®åŸŸ
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_ç”¨æˆ·äº¤äº’åŸŸ
- è¾¹ç•Œè°ƒç”¨
- æ ¸å¿ƒæ¨¡å—ä¸ç»„ä»¶è°ƒç ”æŠ¥å‘Š_ç³»ç»Ÿæ”¯æ’‘åŸŸ
- æ¶æ„è¯´æ˜
- é¡¹ç›®æ¦‚è¿°
- æ ¸å¿ƒæµç¨‹
